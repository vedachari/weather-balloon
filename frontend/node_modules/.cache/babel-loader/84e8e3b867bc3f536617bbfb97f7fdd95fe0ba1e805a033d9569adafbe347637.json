{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressGesture - Detects press and hold interactions\n *\n * This gesture tracks when users press and hold on an element for a specified duration, firing events when:\n * - The press begins and passes the holding threshold time (start, ongoing)\n * - The press ends (end)\n * - The press is canceled by movement beyond threshold (cancel)\n *\n * This gesture is commonly used for contextual menus, revealing additional options, or alternate actions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for PressGesture\n * Extends PointerGestureOptions with press-specific options\n */\n\n/**\n * Event data specific to press gesture events\n * Contains information about the press location and duration\n */\n\n/**\n * Type definition for the CustomEvent created by PressGesture\n */\n\n/**\n * State tracking for the PressGesture\n */\n\n/**\n * PressGesture class for handling press/hold interactions\n *\n * This gesture detects when users press and hold on an element for a specified duration,\n * and dispatches press-related events when the user holds long enough.\n *\n * The `start` and `ongoing` events are dispatched at the same time once the press threshold is reached.\n * If the press is canceled (event.g., by moving too far), a `cancel` event is dispatched before the `end` event.\n */\nexport class PressGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    lastPosition: null,\n    timerId: null,\n    startTime: 0,\n    pressThresholdReached: false\n  };\n\n  /**\n   * Duration in milliseconds required to hold before the press gesture is recognized\n   */\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a press\n   */\n\n  constructor(options) {\n    super(options);\n    this.duration = options.duration ?? 500;\n    this.maxDistance = options.maxDistance ?? 10;\n  }\n  clone(overrides) {\n    return new PressGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      duration: this.duration,\n      maxDistance: this.maxDistance,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.clearPressTimer();\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.duration = options.duration ?? this.duration;\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n  }\n  resetState() {\n    this.clearPressTimer();\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startCentroid: null,\n      lastPosition: null,\n      timerId: null,\n      startTime: 0,\n      pressThresholdReached: false\n    });\n  }\n\n  /**\n   * Clear the press timer if it's active\n   */\n  clearPressTimer() {\n    if (this.state.timerId !== null) {\n      clearTimeout(this.state.timerId);\n      this.state.timerId = null;\n    }\n  }\n\n  /**\n   * Handle pointer events for the press gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active press gestures when we get a force reset event\n      this.cancelPress(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, cancel it gracefully\n        this.cancelPress(targetElement, pointersArray, event);\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel or end the gesture if it was active\n        this.cancelPress(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.state.startTime = event.timeStamp;\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Start the timer for press recognition\n          this.clearPressTimer(); // Clear any existing timer first\n          this.state.timerId = setTimeout(() => {\n            if (this.isActive && this.state.startCentroid) {\n              this.state.pressThresholdReached = true;\n              const lastPosition = this.state.lastPosition;\n\n              // Emit press start event\n              this.emitPressEvent(targetElement, 'start', relevantPointers, event, lastPosition);\n              this.emitPressEvent(targetElement, 'ongoing', relevantPointers, event, lastPosition);\n            }\n          }, this.duration);\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the press gesture\n          if (distance > this.maxDistance) {\n            this.cancelPress(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          if (this.state.pressThresholdReached) {\n            // Complete the press gesture if we've held long enough\n            const position = this.state.lastPosition || this.state.startCentroid;\n            this.emitPressEvent(targetElement, 'end', relevantPointers, event, position);\n          }\n\n          // Reset state\n          this.resetState();\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelPress(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit press-specific events with additional data\n   */\n  emitPressEvent(element, phase, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Calculate current duration of the press\n    const currentDuration = event.timeStamp - this.state.startTime;\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      duration: currentDuration,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current press gesture\n   */\n  cancelPress(element, pointers, event) {\n    if (this.isActive && this.state.pressThresholdReached) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n      this.emitPressEvent(element ?? this.element, 'cancel', pointers, event, position);\n      this.emitPressEvent(element ?? this.element, 'end', pointers, event, position);\n    }\n    this.resetState();\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","calculateCentroid","createEventName","PressGesture","state","startCentroid","lastPosition","timerId","startTime","pressThresholdReached","constructor","options","duration","maxDistance","clone","overrides","name","preventDefault","stopPropagation","minPointers","maxPointers","requiredKeys","pointerMode","preventIf","pointerOptions","structuredClone","destroy","clearPressTimer","resetState","updateOptions","isActive","clearTimeout","handlePointerEvent","pointers","event","pointersArray","Array","from","values","type","cancelPress","target","targetElement","getTargetElement","shouldPreventGesture","pointerType","relevantPointers","getRelevantPointers","isWithinPointerCount","timeStamp","originalTarget","setTimeout","emitPressEvent","currentPosition","deltaX","x","deltaY","y","distance","Math","sqrt","position","element","phase","activeGestures","gesturesRegistry","getActiveGestures","currentDuration","customEventData","gestureName","centroid","srcEvent","customData","eventName","domEvent","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/PressGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressGesture - Detects press and hold interactions\n *\n * This gesture tracks when users press and hold on an element for a specified duration, firing events when:\n * - The press begins and passes the holding threshold time (start, ongoing)\n * - The press ends (end)\n * - The press is canceled by movement beyond threshold (cancel)\n *\n * This gesture is commonly used for contextual menus, revealing additional options, or alternate actions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for PressGesture\n * Extends PointerGestureOptions with press-specific options\n */\n\n/**\n * Event data specific to press gesture events\n * Contains information about the press location and duration\n */\n\n/**\n * Type definition for the CustomEvent created by PressGesture\n */\n\n/**\n * State tracking for the PressGesture\n */\n\n/**\n * PressGesture class for handling press/hold interactions\n *\n * This gesture detects when users press and hold on an element for a specified duration,\n * and dispatches press-related events when the user holds long enough.\n *\n * The `start` and `ongoing` events are dispatched at the same time once the press threshold is reached.\n * If the press is canceled (event.g., by moving too far), a `cancel` event is dispatched before the `end` event.\n */\nexport class PressGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    lastPosition: null,\n    timerId: null,\n    startTime: 0,\n    pressThresholdReached: false\n  };\n\n  /**\n   * Duration in milliseconds required to hold before the press gesture is recognized\n   */\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a press\n   */\n\n  constructor(options) {\n    super(options);\n    this.duration = options.duration ?? 500;\n    this.maxDistance = options.maxDistance ?? 10;\n  }\n  clone(overrides) {\n    return new PressGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      duration: this.duration,\n      maxDistance: this.maxDistance,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.clearPressTimer();\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.duration = options.duration ?? this.duration;\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n  }\n  resetState() {\n    this.clearPressTimer();\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startCentroid: null,\n      lastPosition: null,\n      timerId: null,\n      startTime: 0,\n      pressThresholdReached: false\n    });\n  }\n\n  /**\n   * Clear the press timer if it's active\n   */\n  clearPressTimer() {\n    if (this.state.timerId !== null) {\n      clearTimeout(this.state.timerId);\n      this.state.timerId = null;\n    }\n  }\n\n  /**\n   * Handle pointer events for the press gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active press gestures when we get a force reset event\n      this.cancelPress(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, cancel it gracefully\n        this.cancelPress(targetElement, pointersArray, event);\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel or end the gesture if it was active\n        this.cancelPress(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.state.startTime = event.timeStamp;\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Start the timer for press recognition\n          this.clearPressTimer(); // Clear any existing timer first\n          this.state.timerId = setTimeout(() => {\n            if (this.isActive && this.state.startCentroid) {\n              this.state.pressThresholdReached = true;\n              const lastPosition = this.state.lastPosition;\n\n              // Emit press start event\n              this.emitPressEvent(targetElement, 'start', relevantPointers, event, lastPosition);\n              this.emitPressEvent(targetElement, 'ongoing', relevantPointers, event, lastPosition);\n            }\n          }, this.duration);\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the press gesture\n          if (distance > this.maxDistance) {\n            this.cancelPress(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          if (this.state.pressThresholdReached) {\n            // Complete the press gesture if we've held long enough\n            const position = this.state.lastPosition || this.state.startCentroid;\n            this.emitPressEvent(targetElement, 'end', relevantPointers, event, position);\n          }\n\n          // Reset state\n          this.resetState();\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelPress(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit press-specific events with additional data\n   */\n  emitPressEvent(element, phase, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Calculate current duration of the press\n    const currentDuration = event.timeStamp - this.state.startTime;\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      duration: currentDuration,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current press gesture\n   */\n  cancelPress(element, pointers, event) {\n    if (this.isActive && this.state.pressThresholdReached) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n      this.emitPressEvent(element ?? this.element, 'cancel', pointers, event, position);\n      this.emitPressEvent(element ?? this.element, 'end', pointers, event, position);\n    }\n    this.resetState();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}