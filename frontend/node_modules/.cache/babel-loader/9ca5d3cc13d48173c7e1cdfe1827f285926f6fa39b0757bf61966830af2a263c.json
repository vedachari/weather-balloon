{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createScalarFormatter } from \"../../../defaultValueFormatters.js\";\nimport { isBandScaleConfig, isPointScaleConfig } from \"../../../../models/axis.js\";\nimport { getColorScale, getOrdinalColorScale, getSequentialColorScale } from \"../../../colorScale.js\";\nimport { scaleTickNumberByRange } from \"../../../ticks.js\";\nimport { getScale } from \"../../../getScale.js\";\nimport { isDateData, createDateFormatter } from \"../../../dateHelpers.js\";\nimport { getAxisTriggerTooltip } from \"./getAxisTriggerTooltip.js\";\nimport { isBandScale, isOrdinalScale } from \"../../../scaleGuards.js\";\nfunction getRange(drawingArea, axisDirection,\n// | 'rotation' | 'radius',\nreverse) {\n  const range = axisDirection === 'x' ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];\n  return reverse ? [range[1], range[0]] : range;\n}\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport function computeAxisValue({\n  scales,\n  drawingArea,\n  formattedSeries,\n  axis: allAxis,\n  seriesConfig,\n  axisDirection,\n  zoomMap,\n  domains\n}) {\n  if (allAxis === undefined) {\n    return {\n      axis: {},\n      axisIds: []\n    };\n  }\n  const axisIdsTriggeringTooltip = getAxisTriggerTooltip(axisDirection, seriesConfig, formattedSeries, allAxis[0].id);\n  const completeAxis = {};\n  allAxis.forEach(eachAxis => {\n    const axis = eachAxis;\n    const scale = scales[axis.id];\n    const zoom = zoomMap?.get(axis.id);\n    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];\n    const range = getRange(drawingArea, axisDirection, axis.reverse ?? false);\n    const triggerTooltip = !axis.ignoreTooltip && axisIdsTriggeringTooltip.has(axis.id);\n    const data = axis.data ?? [];\n    if (isOrdinalScale(scale)) {\n      // Reverse range because ordinal scales are presented from top to bottom on y-axis\n      const scaleRange = axisDirection === 'y' ? [range[1], range[0]] : range;\n      if (isBandScale(scale) && isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completeAxis[axis.id] = _extends({\n          offset: 0,\n          height: 0,\n          categoryGapRatio,\n          barGapRatio,\n          triggerTooltip\n        }, axis, {\n          data,\n          scale,\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completeAxis[axis.id] = _extends({\n          offset: 0,\n          height: 0,\n          triggerTooltip\n        }, axis, {\n          data,\n          scale,\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isDateData(axis.data)) {\n        const dateFormatter = createDateFormatter(axis.data, scaleRange, axis.tickNumber);\n        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;\n      }\n      return;\n    }\n    if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n      // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n      return;\n    }\n    const rawTickNumber = domains[axis.id].tickNumber;\n    const continuousAxis = axis;\n    const scaleType = continuousAxis.scaleType ?? 'linear';\n    const tickNumber = scaleTickNumberByRange(rawTickNumber, zoomRange);\n    completeAxis[axis.id] = _extends({\n      offset: 0,\n      height: 0,\n      triggerTooltip\n    }, continuousAxis, {\n      data,\n      scaleType,\n      scale,\n      tickNumber,\n      colorScale: continuousAxis.colorMap && getSequentialColorScale(continuousAxis.colorMap),\n      valueFormatter: axis.valueFormatter ?? createScalarFormatter(tickNumber, getScale(scaleType, range.map(v => scale.invert(v)), range))\n    });\n  });\n  return {\n    axis: completeAxis,\n    axisIds: allAxis.map(({\n      id\n    }) => id)\n  };\n}","map":{"version":3,"names":["_extends","createScalarFormatter","isBandScaleConfig","isPointScaleConfig","getColorScale","getOrdinalColorScale","getSequentialColorScale","scaleTickNumberByRange","getScale","isDateData","createDateFormatter","getAxisTriggerTooltip","isBandScale","isOrdinalScale","getRange","drawingArea","axisDirection","reverse","range","left","width","top","height","DEFAULT_CATEGORY_GAP_RATIO","DEFAULT_BAR_GAP_RATIO","computeAxisValue","scales","formattedSeries","axis","allAxis","seriesConfig","zoomMap","domains","undefined","axisIds","axisIdsTriggeringTooltip","id","completeAxis","forEach","eachAxis","scale","zoom","get","zoomRange","start","end","triggerTooltip","ignoreTooltip","has","data","scaleRange","categoryGapRatio","barGapRatio","offset","tickNumber","length","colorScale","colorMap","type","values","dateFormatter","valueFormatter","scaleType","rawTickNumber","continuousAxis","map","v","invert"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/computeAxisValue.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createScalarFormatter } from \"../../../defaultValueFormatters.js\";\nimport { isBandScaleConfig, isPointScaleConfig } from \"../../../../models/axis.js\";\nimport { getColorScale, getOrdinalColorScale, getSequentialColorScale } from \"../../../colorScale.js\";\nimport { scaleTickNumberByRange } from \"../../../ticks.js\";\nimport { getScale } from \"../../../getScale.js\";\nimport { isDateData, createDateFormatter } from \"../../../dateHelpers.js\";\nimport { getAxisTriggerTooltip } from \"./getAxisTriggerTooltip.js\";\nimport { isBandScale, isOrdinalScale } from \"../../../scaleGuards.js\";\nfunction getRange(drawingArea, axisDirection,\n// | 'rotation' | 'radius',\nreverse) {\n  const range = axisDirection === 'x' ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];\n  return reverse ? [range[1], range[0]] : range;\n}\nconst DEFAULT_CATEGORY_GAP_RATIO = 0.2;\nconst DEFAULT_BAR_GAP_RATIO = 0.1;\nexport function computeAxisValue({\n  scales,\n  drawingArea,\n  formattedSeries,\n  axis: allAxis,\n  seriesConfig,\n  axisDirection,\n  zoomMap,\n  domains\n}) {\n  if (allAxis === undefined) {\n    return {\n      axis: {},\n      axisIds: []\n    };\n  }\n  const axisIdsTriggeringTooltip = getAxisTriggerTooltip(axisDirection, seriesConfig, formattedSeries, allAxis[0].id);\n  const completeAxis = {};\n  allAxis.forEach(eachAxis => {\n    const axis = eachAxis;\n    const scale = scales[axis.id];\n    const zoom = zoomMap?.get(axis.id);\n    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];\n    const range = getRange(drawingArea, axisDirection, axis.reverse ?? false);\n    const triggerTooltip = !axis.ignoreTooltip && axisIdsTriggeringTooltip.has(axis.id);\n    const data = axis.data ?? [];\n    if (isOrdinalScale(scale)) {\n      // Reverse range because ordinal scales are presented from top to bottom on y-axis\n      const scaleRange = axisDirection === 'y' ? [range[1], range[0]] : range;\n      if (isBandScale(scale) && isBandScaleConfig(axis)) {\n        const categoryGapRatio = axis.categoryGapRatio ?? DEFAULT_CATEGORY_GAP_RATIO;\n        const barGapRatio = axis.barGapRatio ?? DEFAULT_BAR_GAP_RATIO;\n        completeAxis[axis.id] = _extends({\n          offset: 0,\n          height: 0,\n          categoryGapRatio,\n          barGapRatio,\n          triggerTooltip\n        }, axis, {\n          data,\n          scale,\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isPointScaleConfig(axis)) {\n        completeAxis[axis.id] = _extends({\n          offset: 0,\n          height: 0,\n          triggerTooltip\n        }, axis, {\n          data,\n          scale,\n          tickNumber: axis.data.length,\n          colorScale: axis.colorMap && (axis.colorMap.type === 'ordinal' ? getOrdinalColorScale(_extends({\n            values: axis.data\n          }, axis.colorMap)) : getColorScale(axis.colorMap))\n        });\n      }\n      if (isDateData(axis.data)) {\n        const dateFormatter = createDateFormatter(axis.data, scaleRange, axis.tickNumber);\n        completeAxis[axis.id].valueFormatter = axis.valueFormatter ?? dateFormatter;\n      }\n      return;\n    }\n    if (axis.scaleType === 'band' || axis.scaleType === 'point') {\n      // Could be merged with the two previous \"if conditions\" but then TS does not get that `axis.scaleType` can't be `band` or `point`.\n      return;\n    }\n    const rawTickNumber = domains[axis.id].tickNumber;\n    const continuousAxis = axis;\n    const scaleType = continuousAxis.scaleType ?? 'linear';\n    const tickNumber = scaleTickNumberByRange(rawTickNumber, zoomRange);\n    completeAxis[axis.id] = _extends({\n      offset: 0,\n      height: 0,\n      triggerTooltip\n    }, continuousAxis, {\n      data,\n      scaleType,\n      scale,\n      tickNumber,\n      colorScale: continuousAxis.colorMap && getSequentialColorScale(continuousAxis.colorMap),\n      valueFormatter: axis.valueFormatter ?? createScalarFormatter(tickNumber, getScale(scaleType, range.map(v => scale.invert(v)), range))\n    });\n  });\n  return {\n    axis: completeAxis,\n    axisIds: allAxis.map(({\n      id\n    }) => id)\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}