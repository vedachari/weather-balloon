{"ast":null,"code":"/**\n * Returns the next series type and id that contains some data.\n * Returns `null` if no other series have data.\n */\nexport function getNextSeriesWithData(series, type, seriesId) {\n  const startingTypeIndex = type !== undefined && series[type] ? Object.keys(series).indexOf(type) : 0;\n  const currentSeriesIndex = type !== undefined && seriesId !== undefined && series[type] && series[type].series[seriesId] ? series[type].seriesOrder.indexOf(seriesId) : -1;\n  const typesAvailable = Object.keys(series).filter(t => t !== 'sankey');\n\n  // Loop over all series types starting with the current seriesType\n  for (let typeGap = 0; typeGap < typesAvailable.length; typeGap += 1) {\n    const typeIndex = (startingTypeIndex + typeGap) % typesAvailable.length;\n    const seriesOfType = series[typesAvailable[typeIndex]];\n\n    // Edge case for the current series type: we don't loop on previous series of the same type.\n    const startingSeriesIndex = typeGap === 0 ? currentSeriesIndex + 1 : 0;\n    for (let seriesIndex = startingSeriesIndex; seriesIndex < seriesOfType.seriesOrder.length; seriesIndex += 1) {\n      if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n        return {\n          type: typesAvailable[typeIndex],\n          seriesId: seriesOfType.seriesOrder[seriesIndex]\n        };\n      }\n    }\n  }\n\n  // End looping on the initial type up to the initial series (excluded)\n  const typeIndex = startingTypeIndex;\n  const seriesOfType = series[typesAvailable[typeIndex]];\n  const endingSeriesIndex = currentSeriesIndex;\n  for (let seriesIndex = 0; seriesIndex < endingSeriesIndex; seriesIndex += 1) {\n    if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n      return {\n        type: typesAvailable[typeIndex],\n        seriesId: seriesOfType.seriesOrder[seriesIndex]\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the previous series type and id that contains some data.\n * Returns `null` if no other series have data.\n */\nexport function getPreviousSeriesWithData(series, type, seriesId) {\n  const startingTypeIndex = type !== undefined && series[type] ? Object.keys(series).indexOf(type) : 0;\n  const startingSeriesIndex = type !== undefined && seriesId !== undefined && series[type] && series[type].series[seriesId] ? series[type].seriesOrder.indexOf(seriesId) : 1;\n  const typesAvailable = Object.keys(series).filter(t => t !== 'sankey');\n\n  // Loop over all series types starting with the current seriesType\n  for (let typeGap = 0; typeGap < typesAvailable.length; typeGap += 1) {\n    const typeIndex = (typesAvailable.length + startingTypeIndex - typeGap) % typesAvailable.length;\n    const seriesOfType = series[typesAvailable[typeIndex]];\n    const maxGap = typeGap === 0 ? startingSeriesIndex + 1 : seriesOfType.seriesOrder.length;\n    for (let seriesGap = 1; seriesGap < maxGap; seriesGap += 1) {\n      const seriesIndex = (seriesOfType.seriesOrder.length + startingSeriesIndex - seriesGap) % seriesOfType.seriesOrder.length;\n      if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n        return {\n          type: typesAvailable[typeIndex],\n          seriesId: seriesOfType.seriesOrder[seriesIndex]\n        };\n      }\n    }\n  }\n\n  // End looping on the initial type down to the initial series (excluded)\n  const typeIndex = startingTypeIndex;\n  const seriesOfType = series[typesAvailable[typeIndex]];\n  const availableSeriesIds = seriesOfType.seriesOrder;\n  for (let seriesIndex = availableSeriesIds.length - 1; seriesIndex > startingSeriesIndex; seriesIndex -= 1) {\n    if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n      return {\n        type: typesAvailable[typeIndex],\n        seriesId: seriesOfType.seriesOrder[seriesIndex]\n      };\n    }\n  }\n  return null;\n}\nexport function seriesHasData(series, type, seriesId) {\n  // @ts-ignore snakey is not in MIT version\n  if (type === 'sankey') {\n    return false;\n  }\n  const data = series[type]?.series[seriesId]?.data;\n  return data && data.length > 0;\n}","map":{"version":3,"names":["getNextSeriesWithData","series","type","seriesId","startingTypeIndex","undefined","Object","keys","indexOf","currentSeriesIndex","seriesOrder","typesAvailable","filter","t","typeGap","length","typeIndex","seriesOfType","startingSeriesIndex","seriesIndex","data","endingSeriesIndex","getPreviousSeriesWithData","maxGap","seriesGap","availableSeriesIds","seriesHasData"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartKeyboardNavigation/useChartKeyboardNavigation.helpers.js"],"sourcesContent":["/**\n * Returns the next series type and id that contains some data.\n * Returns `null` if no other series have data.\n */\nexport function getNextSeriesWithData(series, type, seriesId) {\n  const startingTypeIndex = type !== undefined && series[type] ? Object.keys(series).indexOf(type) : 0;\n  const currentSeriesIndex = type !== undefined && seriesId !== undefined && series[type] && series[type].series[seriesId] ? series[type].seriesOrder.indexOf(seriesId) : -1;\n  const typesAvailable = Object.keys(series).filter(t => t !== 'sankey');\n\n  // Loop over all series types starting with the current seriesType\n  for (let typeGap = 0; typeGap < typesAvailable.length; typeGap += 1) {\n    const typeIndex = (startingTypeIndex + typeGap) % typesAvailable.length;\n    const seriesOfType = series[typesAvailable[typeIndex]];\n\n    // Edge case for the current series type: we don't loop on previous series of the same type.\n    const startingSeriesIndex = typeGap === 0 ? currentSeriesIndex + 1 : 0;\n    for (let seriesIndex = startingSeriesIndex; seriesIndex < seriesOfType.seriesOrder.length; seriesIndex += 1) {\n      if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n        return {\n          type: typesAvailable[typeIndex],\n          seriesId: seriesOfType.seriesOrder[seriesIndex]\n        };\n      }\n    }\n  }\n\n  // End looping on the initial type up to the initial series (excluded)\n  const typeIndex = startingTypeIndex;\n  const seriesOfType = series[typesAvailable[typeIndex]];\n  const endingSeriesIndex = currentSeriesIndex;\n  for (let seriesIndex = 0; seriesIndex < endingSeriesIndex; seriesIndex += 1) {\n    if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n      return {\n        type: typesAvailable[typeIndex],\n        seriesId: seriesOfType.seriesOrder[seriesIndex]\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the previous series type and id that contains some data.\n * Returns `null` if no other series have data.\n */\nexport function getPreviousSeriesWithData(series, type, seriesId) {\n  const startingTypeIndex = type !== undefined && series[type] ? Object.keys(series).indexOf(type) : 0;\n  const startingSeriesIndex = type !== undefined && seriesId !== undefined && series[type] && series[type].series[seriesId] ? series[type].seriesOrder.indexOf(seriesId) : 1;\n  const typesAvailable = Object.keys(series).filter(t => t !== 'sankey');\n\n  // Loop over all series types starting with the current seriesType\n  for (let typeGap = 0; typeGap < typesAvailable.length; typeGap += 1) {\n    const typeIndex = (typesAvailable.length + startingTypeIndex - typeGap) % typesAvailable.length;\n    const seriesOfType = series[typesAvailable[typeIndex]];\n    const maxGap = typeGap === 0 ? startingSeriesIndex + 1 : seriesOfType.seriesOrder.length;\n    for (let seriesGap = 1; seriesGap < maxGap; seriesGap += 1) {\n      const seriesIndex = (seriesOfType.seriesOrder.length + startingSeriesIndex - seriesGap) % seriesOfType.seriesOrder.length;\n      if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n        return {\n          type: typesAvailable[typeIndex],\n          seriesId: seriesOfType.seriesOrder[seriesIndex]\n        };\n      }\n    }\n  }\n\n  // End looping on the initial type down to the initial series (excluded)\n  const typeIndex = startingTypeIndex;\n  const seriesOfType = series[typesAvailable[typeIndex]];\n  const availableSeriesIds = seriesOfType.seriesOrder;\n  for (let seriesIndex = availableSeriesIds.length - 1; seriesIndex > startingSeriesIndex; seriesIndex -= 1) {\n    if (seriesOfType.series[seriesOfType.seriesOrder[seriesIndex]].data.length > 0) {\n      return {\n        type: typesAvailable[typeIndex],\n        seriesId: seriesOfType.seriesOrder[seriesIndex]\n      };\n    }\n  }\n  return null;\n}\nexport function seriesHasData(series, type, seriesId) {\n  // @ts-ignore snakey is not in MIT version\n  if (type === 'sankey') {\n    return false;\n  }\n  const data = series[type]?.series[seriesId]?.data;\n  return data && data.length > 0;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}