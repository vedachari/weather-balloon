{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PointerManager - Centralized manager for pointer events in the gesture recognition system\n *\n * This singleton class abstracts the complexity of working with pointer events by:\n * 1. Capturing and tracking all active pointers (touch, mouse, pen)\n * 2. Normalizing pointer data into a consistent format\n * 3. Managing pointer capture for proper tracking across elements\n * 4. Distributing events to registered gesture recognizers\n */\n\n/**\n * Normalized representation of a pointer, containing all relevant information\n * from the original PointerEvent plus additional tracking data.\n *\n * This data structure encapsulates everything gesture recognizers need to know\n * about a pointer's current state.\n */\n\n/**\n * Configuration options for initializing the PointerManager.\n */\n\n/**\n * Manager for handling pointer events across the application.\n *\n * PointerManager serves as the foundational layer for gesture recognition,\n * providing a centralized system for tracking active pointers and distributing\n * pointer events to gesture recognizers.\n *\n * It normalizes browser pointer events into a consistent format and simplifies\n * multi-touch handling by managing pointer capture and tracking multiple\n * simultaneous pointers.\n */\nexport class PointerManager {\n  /** Root element where pointer events are captured */\n\n  /** CSS touch-action property value applied to the root element */\n\n  /** Whether to use passive event listeners */\n\n  /** Whether to prevent interrupt events like blur or contextmenu */\n  preventEventInterruption = true;\n\n  /** Map of all currently active pointers by their pointerId */\n  pointers = (() => new Map())();\n\n  /** Set of registered gesture handlers that receive pointer events */\n  gestureHandlers = (() => new Set())();\n  constructor(options) {\n    this.root =\n    // User provided root element\n    options.root ??\n    // Fallback to document root or body, this fixes shadow DOM scenarios\n    document.getRootNode({\n      composed: true\n    }) ??\n    // Fallback to document body, for some testing environments\n    document.body;\n    this.touchAction = options.touchAction || 'auto';\n    this.passive = options.passive ?? false;\n    this.preventEventInterruption = options.preventEventInterruption ?? true;\n    this.setupEventListeners();\n  }\n\n  /**\n   * Register a handler function to receive pointer events.\n   *\n   * The handler will be called whenever pointer events occur within the root element.\n   * It receives the current map of all active pointers and the original event.\n   *\n   * @param {Function} handler - Function to receive pointer events and current pointer state\n   * @returns {Function} An unregister function that removes this handler when called\n   */\n  registerGestureHandler(handler) {\n    this.gestureHandlers.add(handler);\n\n    // Return unregister function\n    return () => {\n      this.gestureHandlers.delete(handler);\n    };\n  }\n\n  /**\n   * Get a copy of the current active pointers map.\n   *\n   * Returns a new Map containing all currently active pointers.\n   * Modifying the returned map will not affect the internal pointers state.\n   *\n   * @returns A new Map containing all active pointers\n   */\n  getPointers() {\n    return new Map(this.pointers);\n  }\n\n  /**\n   * Set up event listeners for pointer events on the root element.\n   *\n   * This method attaches all necessary event listeners and configures\n   * the CSS touch-action property on the root element.\n   */\n  setupEventListeners() {\n    // Set touch-action CSS property\n    if (this.touchAction !== 'auto') {\n      this.root.style.touchAction = this.touchAction;\n    }\n\n    // Add event listeners\n    this.root.addEventListener('pointerdown', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointermove', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointerup', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointercancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.addEventListener('forceCancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n\n    // Add blur and contextmenu event listeners to interrupt all gestures\n    this.root.addEventListener('blur', this.handleInterruptEvents);\n    this.root.addEventListener('contextmenu', this.handleInterruptEvents);\n  }\n\n  /**\n   * Handle events that should interrupt all gestures.\n   * This clears all active pointers and notifies handlers with a pointercancel-like event.\n   *\n   * @param event - The event that triggered the interruption (blur or contextmenu)\n   */\n  handleInterruptEvents = event => {\n    if (this.preventEventInterruption && 'pointerType' in event && event.pointerType === 'touch') {\n      event.preventDefault();\n      return;\n    }\n\n    // Create a synthetic pointer cancel event\n    const cancelEvent = new PointerEvent('forceCancel', {\n      bubbles: false,\n      cancelable: false\n    });\n    const firstPointer = this.pointers.values().next().value;\n    if (this.pointers.size > 0 && firstPointer) {\n      // If there are active pointers, use the first one as a template for coordinates\n\n      // Update the synthetic event with the pointer's coordinates\n      Object.defineProperties(cancelEvent, {\n        clientX: {\n          value: firstPointer.clientX\n        },\n        clientY: {\n          value: firstPointer.clientY\n        },\n        pointerId: {\n          value: firstPointer.pointerId\n        },\n        pointerType: {\n          value: firstPointer.pointerType\n        }\n      });\n\n      // Force update of all pointers to have type 'forceCancel'\n      for (const [pointerId, pointer] of this.pointers.entries()) {\n        const updatedPointer = _extends({}, pointer, {\n          type: 'forceCancel'\n        });\n        this.pointers.set(pointerId, updatedPointer);\n      }\n    }\n\n    // Notify all handlers about the interruption\n    this.notifyHandlers(cancelEvent);\n\n    // Clear all pointers\n    this.pointers.clear();\n  };\n\n  /**\n   * Event handler for all pointer events.\n   *\n   * This method:\n   * 1. Updates the internal pointers map based on the event type\n   * 2. Manages pointer capture for tracking pointers outside the root element\n   * 3. Notifies all registered handlers with the current state\n   *\n   * @param event - The original pointer event from the browser\n   */\n  handlePointerEvent = event => {\n    const {\n      type,\n      pointerId\n    } = event;\n\n    // Create or update pointer data\n    if (type === 'pointerdown' || type === 'pointermove') {\n      this.pointers.set(pointerId, this.createPointerData(event));\n    }\n    // Remove pointer data on up or cancel\n    else if (type === 'pointerup' || type === 'pointercancel' || type === 'forceCancel') {\n      // Update one last time before removing\n      this.pointers.set(pointerId, this.createPointerData(event));\n\n      // Notify handlers with current state\n      this.notifyHandlers(event);\n\n      // Then remove the pointer\n      this.pointers.delete(pointerId);\n      return;\n    }\n    this.notifyHandlers(event);\n  };\n\n  /**\n   * Notify all registered gesture handlers about a pointer event.\n   *\n   * Each handler receives the current map of active pointers and the original event.\n   *\n   * @param event - The original pointer event that triggered this notification\n   */\n  notifyHandlers(event) {\n    this.gestureHandlers.forEach(handler => handler(this.pointers, event));\n  }\n\n  /**\n   * Create a normalized PointerData object from a browser PointerEvent.\n   *\n   * This method extracts all relevant information from the original event\n   * and formats it in a consistent way for gesture recognizers to use.\n   *\n   * @param event - The original browser pointer event\n   * @returns A new PointerData object representing this pointer\n   */\n  createPointerData(event) {\n    return {\n      pointerId: event.pointerId,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      pageX: event.pageX,\n      pageY: event.pageY,\n      target: event.target,\n      timeStamp: event.timeStamp,\n      type: event.type,\n      isPrimary: event.isPrimary,\n      pressure: event.pressure,\n      width: event.width,\n      height: event.height,\n      pointerType: event.pointerType,\n      srcEvent: event\n    };\n  }\n\n  /**\n   * Clean up all event listeners and reset the PointerManager state.\n   *\n   * This method should be called when the PointerManager is no longer needed\n   * to prevent memory leaks. It removes all event listeners, clears the\n   * internal state, and resets the singleton instance.\n   */\n  destroy() {\n    this.root.removeEventListener('pointerdown', this.handlePointerEvent);\n    this.root.removeEventListener('pointermove', this.handlePointerEvent);\n    this.root.removeEventListener('pointerup', this.handlePointerEvent);\n    this.root.removeEventListener('pointercancel', this.handlePointerEvent);\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.removeEventListener('forceCancel', this.handlePointerEvent);\n    this.root.removeEventListener('blur', this.handleInterruptEvents);\n    this.root.removeEventListener('contextmenu', this.handleInterruptEvents);\n    this.pointers.clear();\n    this.gestureHandlers.clear();\n  }\n}","map":{"version":3,"names":["_extends","PointerManager","preventEventInterruption","pointers","Map","gestureHandlers","Set","constructor","options","root","document","getRootNode","composed","body","touchAction","passive","setupEventListeners","registerGestureHandler","handler","add","delete","getPointers","style","addEventListener","handlePointerEvent","handleInterruptEvents","event","pointerType","preventDefault","cancelEvent","PointerEvent","bubbles","cancelable","firstPointer","values","next","value","size","Object","defineProperties","clientX","clientY","pointerId","pointer","entries","updatedPointer","type","set","notifyHandlers","clear","createPointerData","forEach","pageX","pageY","target","timeStamp","isPrimary","pressure","width","height","srcEvent","destroy","removeEventListener"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/PointerManager.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PointerManager - Centralized manager for pointer events in the gesture recognition system\n *\n * This singleton class abstracts the complexity of working with pointer events by:\n * 1. Capturing and tracking all active pointers (touch, mouse, pen)\n * 2. Normalizing pointer data into a consistent format\n * 3. Managing pointer capture for proper tracking across elements\n * 4. Distributing events to registered gesture recognizers\n */\n\n/**\n * Normalized representation of a pointer, containing all relevant information\n * from the original PointerEvent plus additional tracking data.\n *\n * This data structure encapsulates everything gesture recognizers need to know\n * about a pointer's current state.\n */\n\n/**\n * Configuration options for initializing the PointerManager.\n */\n\n/**\n * Manager for handling pointer events across the application.\n *\n * PointerManager serves as the foundational layer for gesture recognition,\n * providing a centralized system for tracking active pointers and distributing\n * pointer events to gesture recognizers.\n *\n * It normalizes browser pointer events into a consistent format and simplifies\n * multi-touch handling by managing pointer capture and tracking multiple\n * simultaneous pointers.\n */\nexport class PointerManager {\n  /** Root element where pointer events are captured */\n\n  /** CSS touch-action property value applied to the root element */\n\n  /** Whether to use passive event listeners */\n\n  /** Whether to prevent interrupt events like blur or contextmenu */\n  preventEventInterruption = true;\n\n  /** Map of all currently active pointers by their pointerId */\n  pointers = (() => new Map())();\n\n  /** Set of registered gesture handlers that receive pointer events */\n  gestureHandlers = (() => new Set())();\n  constructor(options) {\n    this.root =\n    // User provided root element\n    options.root ??\n    // Fallback to document root or body, this fixes shadow DOM scenarios\n    document.getRootNode({\n      composed: true\n    }) ??\n    // Fallback to document body, for some testing environments\n    document.body;\n    this.touchAction = options.touchAction || 'auto';\n    this.passive = options.passive ?? false;\n    this.preventEventInterruption = options.preventEventInterruption ?? true;\n    this.setupEventListeners();\n  }\n\n  /**\n   * Register a handler function to receive pointer events.\n   *\n   * The handler will be called whenever pointer events occur within the root element.\n   * It receives the current map of all active pointers and the original event.\n   *\n   * @param {Function} handler - Function to receive pointer events and current pointer state\n   * @returns {Function} An unregister function that removes this handler when called\n   */\n  registerGestureHandler(handler) {\n    this.gestureHandlers.add(handler);\n\n    // Return unregister function\n    return () => {\n      this.gestureHandlers.delete(handler);\n    };\n  }\n\n  /**\n   * Get a copy of the current active pointers map.\n   *\n   * Returns a new Map containing all currently active pointers.\n   * Modifying the returned map will not affect the internal pointers state.\n   *\n   * @returns A new Map containing all active pointers\n   */\n  getPointers() {\n    return new Map(this.pointers);\n  }\n\n  /**\n   * Set up event listeners for pointer events on the root element.\n   *\n   * This method attaches all necessary event listeners and configures\n   * the CSS touch-action property on the root element.\n   */\n  setupEventListeners() {\n    // Set touch-action CSS property\n    if (this.touchAction !== 'auto') {\n      this.root.style.touchAction = this.touchAction;\n    }\n\n    // Add event listeners\n    this.root.addEventListener('pointerdown', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointermove', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointerup', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    this.root.addEventListener('pointercancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.addEventListener('forceCancel', this.handlePointerEvent, {\n      passive: this.passive\n    });\n\n    // Add blur and contextmenu event listeners to interrupt all gestures\n    this.root.addEventListener('blur', this.handleInterruptEvents);\n    this.root.addEventListener('contextmenu', this.handleInterruptEvents);\n  }\n\n  /**\n   * Handle events that should interrupt all gestures.\n   * This clears all active pointers and notifies handlers with a pointercancel-like event.\n   *\n   * @param event - The event that triggered the interruption (blur or contextmenu)\n   */\n  handleInterruptEvents = event => {\n    if (this.preventEventInterruption && 'pointerType' in event && event.pointerType === 'touch') {\n      event.preventDefault();\n      return;\n    }\n\n    // Create a synthetic pointer cancel event\n    const cancelEvent = new PointerEvent('forceCancel', {\n      bubbles: false,\n      cancelable: false\n    });\n    const firstPointer = this.pointers.values().next().value;\n    if (this.pointers.size > 0 && firstPointer) {\n      // If there are active pointers, use the first one as a template for coordinates\n\n      // Update the synthetic event with the pointer's coordinates\n      Object.defineProperties(cancelEvent, {\n        clientX: {\n          value: firstPointer.clientX\n        },\n        clientY: {\n          value: firstPointer.clientY\n        },\n        pointerId: {\n          value: firstPointer.pointerId\n        },\n        pointerType: {\n          value: firstPointer.pointerType\n        }\n      });\n\n      // Force update of all pointers to have type 'forceCancel'\n      for (const [pointerId, pointer] of this.pointers.entries()) {\n        const updatedPointer = _extends({}, pointer, {\n          type: 'forceCancel'\n        });\n        this.pointers.set(pointerId, updatedPointer);\n      }\n    }\n\n    // Notify all handlers about the interruption\n    this.notifyHandlers(cancelEvent);\n\n    // Clear all pointers\n    this.pointers.clear();\n  };\n\n  /**\n   * Event handler for all pointer events.\n   *\n   * This method:\n   * 1. Updates the internal pointers map based on the event type\n   * 2. Manages pointer capture for tracking pointers outside the root element\n   * 3. Notifies all registered handlers with the current state\n   *\n   * @param event - The original pointer event from the browser\n   */\n  handlePointerEvent = event => {\n    const {\n      type,\n      pointerId\n    } = event;\n\n    // Create or update pointer data\n    if (type === 'pointerdown' || type === 'pointermove') {\n      this.pointers.set(pointerId, this.createPointerData(event));\n    }\n    // Remove pointer data on up or cancel\n    else if (type === 'pointerup' || type === 'pointercancel' || type === 'forceCancel') {\n      // Update one last time before removing\n      this.pointers.set(pointerId, this.createPointerData(event));\n\n      // Notify handlers with current state\n      this.notifyHandlers(event);\n\n      // Then remove the pointer\n      this.pointers.delete(pointerId);\n      return;\n    }\n    this.notifyHandlers(event);\n  };\n\n  /**\n   * Notify all registered gesture handlers about a pointer event.\n   *\n   * Each handler receives the current map of active pointers and the original event.\n   *\n   * @param event - The original pointer event that triggered this notification\n   */\n  notifyHandlers(event) {\n    this.gestureHandlers.forEach(handler => handler(this.pointers, event));\n  }\n\n  /**\n   * Create a normalized PointerData object from a browser PointerEvent.\n   *\n   * This method extracts all relevant information from the original event\n   * and formats it in a consistent way for gesture recognizers to use.\n   *\n   * @param event - The original browser pointer event\n   * @returns A new PointerData object representing this pointer\n   */\n  createPointerData(event) {\n    return {\n      pointerId: event.pointerId,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      pageX: event.pageX,\n      pageY: event.pageY,\n      target: event.target,\n      timeStamp: event.timeStamp,\n      type: event.type,\n      isPrimary: event.isPrimary,\n      pressure: event.pressure,\n      width: event.width,\n      height: event.height,\n      pointerType: event.pointerType,\n      srcEvent: event\n    };\n  }\n\n  /**\n   * Clean up all event listeners and reset the PointerManager state.\n   *\n   * This method should be called when the PointerManager is no longer needed\n   * to prevent memory leaks. It removes all event listeners, clears the\n   * internal state, and resets the singleton instance.\n   */\n  destroy() {\n    this.root.removeEventListener('pointerdown', this.handlePointerEvent);\n    this.root.removeEventListener('pointermove', this.handlePointerEvent);\n    this.root.removeEventListener('pointerup', this.handlePointerEvent);\n    this.root.removeEventListener('pointercancel', this.handlePointerEvent);\n    // @ts-expect-error, forceCancel is not a standard event, but used for custom handling\n    this.root.removeEventListener('forceCancel', this.handlePointerEvent);\n    this.root.removeEventListener('blur', this.handleInterruptEvents);\n    this.root.removeEventListener('contextmenu', this.handleInterruptEvents);\n    this.pointers.clear();\n    this.gestureHandlers.clear();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}