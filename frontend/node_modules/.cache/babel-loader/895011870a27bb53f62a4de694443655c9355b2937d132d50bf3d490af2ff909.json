{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PinchGesture - Detects pinch (zoom) movements with two or more pointers\n *\n * This gesture tracks when multiple pointers move toward or away from each other, firing events when:\n * - Two or more pointers begin moving (start)\n * - The pointers continue changing distance (ongoing)\n * - One or more pointers are released or lifted (end)\n *\n * This gesture is commonly used to implement zoom functionality in touch interfaces.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateAverageDistance, calculateCentroid, createEventName, getPinchDirection } from \"../utils/index.js\";\n\n/**\n * Configuration options for the PinchGesture\n * Uses the same options as the base PointerGesture\n */\n\n/**\n * Event data specific to pinch gesture events\n * Contains information about scale, distance, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PinchGesture\n */\n\n/**\n * State tracking for the PinchGesture\n */\n\n/**\n * PinchGesture class for handling pinch/zoom interactions\n *\n * This gesture detects when users move multiple pointers toward or away from each other,\n * and dispatches scale-related events with distance and velocity information.\n */\nexport class PinchGesture extends PointerGesture {\n  state = {\n    startDistance: 0,\n    lastDistance: 0,\n    lastScale: 1,\n    lastTime: 0,\n    velocity: 0,\n    totalScale: 1,\n    deltaScale: 0\n  };\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  constructor(options) {\n    super(_extends({}, options, {\n      minPointers: options.minPointers ?? 2\n    }));\n    this.threshold = options.threshold ?? 0;\n  }\n  clone(overrides) {\n    return new PinchGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startDistance: 0,\n      lastDistance: 0,\n      lastScale: 1,\n      lastTime: 0,\n      velocity: 0,\n      deltaScale: 0\n    });\n  }\n\n  /**\n   * Handle pointer events for the pinch gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, end it gracefully\n        this.emitPinchEvent(targetElement, 'cancel', pointersArray, event);\n        this.resetState();\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    switch (event.type) {\n      case 'pointerdown':\n        if (relevantPointers.length >= 2 && !this.isActive) {\n          // Calculate and store the starting distance between pointers\n          const initialDistance = calculateAverageDistance(relevantPointers);\n          this.state.startDistance = initialDistance;\n          this.state.lastDistance = initialDistance;\n          this.state.lastTime = event.timeStamp;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startDistance && this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n          // Calculate current distance between pointers\n          const currentDistance = calculateAverageDistance(relevantPointers);\n\n          // Calculate absolute distance change\n          const distanceChange = Math.abs(currentDistance - this.state.lastDistance);\n\n          // Only proceed if the distance between pointers has changed enough\n          if (distanceChange !== 0 && distanceChange >= this.threshold) {\n            // Calculate scale relative to starting distance\n            const scale = this.state.startDistance ? currentDistance / this.state.startDistance : 1;\n\n            // Calculate the relative scale change since last event\n            const scaleChange = scale / this.state.lastScale;\n            // Apply this change to the total accumulated scale\n            this.state.totalScale *= scaleChange;\n            // Calculate velocity (change in scale over time)\n            const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\n            if (this.state.lastDistance) {\n              const deltaDistance = currentDistance - this.state.lastDistance;\n              const result = deltaDistance / deltaTime;\n              this.state.velocity = Number.isNaN(result) ? 0 : result;\n            }\n\n            // Update state\n            this.state.lastDistance = currentDistance;\n            this.state.deltaScale = scale - this.state.lastScale;\n            this.state.lastScale = scale;\n            this.state.lastTime = event.timeStamp;\n            if (!this.isActive) {\n              // Mark gesture as active\n              this.isActive = true;\n\n              // Emit start event\n              this.emitPinchEvent(targetElement, 'start', relevantPointers, event);\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            } else {\n              // Emit ongoing event\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            }\n          }\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        if (this.isActive) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            if (event.type === 'pointercancel') {\n              this.emitPinchEvent(targetElement, 'cancel', relevantPointers, event);\n            }\n            this.emitPinchEvent(targetElement, 'end', relevantPointers, event);\n\n            // Reset state\n            this.resetState();\n          } else if (remainingPointers.length >= 2) {\n            // If we still have enough pointers, update the start distance\n            // to prevent jumping when a finger is lifted\n            const newDistance = calculateAverageDistance(remainingPointers);\n            this.state.startDistance = newDistance / this.state.lastScale;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pinch-specific events with additional data\n   */\n  emitPinchEvent(element, phase, pointers, event) {\n    // Calculate current centroid\n    const centroid = calculateCentroid(pointers);\n\n    // Create custom event data\n    const distance = this.state.lastDistance;\n    const scale = this.state.lastScale;\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      scale,\n      deltaScale: this.state.deltaScale,\n      totalScale: this.state.totalScale,\n      distance,\n      velocity: this.state.velocity,\n      activeGestures,\n      direction: getPinchDirection(this.state.velocity),\n      customData: this.customData\n    };\n\n    // Handle default event behavior\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","calculateAverageDistance","calculateCentroid","createEventName","getPinchDirection","PinchGesture","state","startDistance","lastDistance","lastScale","lastTime","velocity","totalScale","deltaScale","constructor","options","minPointers","threshold","clone","overrides","name","preventDefault","stopPropagation","maxPointers","requiredKeys","pointerMode","preventIf","pointerOptions","structuredClone","destroy","resetState","updateOptions","isActive","handlePointerEvent","pointers","event","pointersArray","Array","from","values","targetElement","getTargetElement","shouldPreventGesture","pointerType","emitPinchEvent","relevantPointers","getRelevantPointers","type","length","initialDistance","timeStamp","originalTarget","isWithinPointerCount","currentDistance","distanceChange","Math","abs","scale","scaleChange","deltaTime","deltaDistance","result","Number","isNaN","remainingPointers","filter","p","newDistance","element","phase","centroid","distance","activeGestures","gesturesRegistry","getActiveGestures","customEventData","gestureName","target","srcEvent","direction","customData","eventName","domEvent","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/PinchGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PinchGesture - Detects pinch (zoom) movements with two or more pointers\n *\n * This gesture tracks when multiple pointers move toward or away from each other, firing events when:\n * - Two or more pointers begin moving (start)\n * - The pointers continue changing distance (ongoing)\n * - One or more pointers are released or lifted (end)\n *\n * This gesture is commonly used to implement zoom functionality in touch interfaces.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateAverageDistance, calculateCentroid, createEventName, getPinchDirection } from \"../utils/index.js\";\n\n/**\n * Configuration options for the PinchGesture\n * Uses the same options as the base PointerGesture\n */\n\n/**\n * Event data specific to pinch gesture events\n * Contains information about scale, distance, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PinchGesture\n */\n\n/**\n * State tracking for the PinchGesture\n */\n\n/**\n * PinchGesture class for handling pinch/zoom interactions\n *\n * This gesture detects when users move multiple pointers toward or away from each other,\n * and dispatches scale-related events with distance and velocity information.\n */\nexport class PinchGesture extends PointerGesture {\n  state = {\n    startDistance: 0,\n    lastDistance: 0,\n    lastScale: 1,\n    lastTime: 0,\n    velocity: 0,\n    totalScale: 1,\n    deltaScale: 0\n  };\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  constructor(options) {\n    super(_extends({}, options, {\n      minPointers: options.minPointers ?? 2\n    }));\n    this.threshold = options.threshold ?? 0;\n  }\n  clone(overrides) {\n    return new PinchGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startDistance: 0,\n      lastDistance: 0,\n      lastScale: 1,\n      lastTime: 0,\n      velocity: 0,\n      deltaScale: 0\n    });\n  }\n\n  /**\n   * Handle pointer events for the pinch gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, end it gracefully\n        this.emitPinchEvent(targetElement, 'cancel', pointersArray, event);\n        this.resetState();\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    switch (event.type) {\n      case 'pointerdown':\n        if (relevantPointers.length >= 2 && !this.isActive) {\n          // Calculate and store the starting distance between pointers\n          const initialDistance = calculateAverageDistance(relevantPointers);\n          this.state.startDistance = initialDistance;\n          this.state.lastDistance = initialDistance;\n          this.state.lastTime = event.timeStamp;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startDistance && this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n          // Calculate current distance between pointers\n          const currentDistance = calculateAverageDistance(relevantPointers);\n\n          // Calculate absolute distance change\n          const distanceChange = Math.abs(currentDistance - this.state.lastDistance);\n\n          // Only proceed if the distance between pointers has changed enough\n          if (distanceChange !== 0 && distanceChange >= this.threshold) {\n            // Calculate scale relative to starting distance\n            const scale = this.state.startDistance ? currentDistance / this.state.startDistance : 1;\n\n            // Calculate the relative scale change since last event\n            const scaleChange = scale / this.state.lastScale;\n            // Apply this change to the total accumulated scale\n            this.state.totalScale *= scaleChange;\n            // Calculate velocity (change in scale over time)\n            const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\n            if (this.state.lastDistance) {\n              const deltaDistance = currentDistance - this.state.lastDistance;\n              const result = deltaDistance / deltaTime;\n              this.state.velocity = Number.isNaN(result) ? 0 : result;\n            }\n\n            // Update state\n            this.state.lastDistance = currentDistance;\n            this.state.deltaScale = scale - this.state.lastScale;\n            this.state.lastScale = scale;\n            this.state.lastTime = event.timeStamp;\n            if (!this.isActive) {\n              // Mark gesture as active\n              this.isActive = true;\n\n              // Emit start event\n              this.emitPinchEvent(targetElement, 'start', relevantPointers, event);\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            } else {\n              // Emit ongoing event\n              this.emitPinchEvent(targetElement, 'ongoing', relevantPointers, event);\n            }\n          }\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        if (this.isActive) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            if (event.type === 'pointercancel') {\n              this.emitPinchEvent(targetElement, 'cancel', relevantPointers, event);\n            }\n            this.emitPinchEvent(targetElement, 'end', relevantPointers, event);\n\n            // Reset state\n            this.resetState();\n          } else if (remainingPointers.length >= 2) {\n            // If we still have enough pointers, update the start distance\n            // to prevent jumping when a finger is lifted\n            const newDistance = calculateAverageDistance(remainingPointers);\n            this.state.startDistance = newDistance / this.state.lastScale;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pinch-specific events with additional data\n   */\n  emitPinchEvent(element, phase, pointers, event) {\n    // Calculate current centroid\n    const centroid = calculateCentroid(pointers);\n\n    // Create custom event data\n    const distance = this.state.lastDistance;\n    const scale = this.state.lastScale;\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      scale,\n      deltaScale: this.state.deltaScale,\n      totalScale: this.state.totalScale,\n      distance,\n      velocity: this.state.velocity,\n      activeGestures,\n      direction: getPinchDirection(this.state.velocity),\n      customData: this.customData\n    };\n\n    // Handle default event behavior\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}