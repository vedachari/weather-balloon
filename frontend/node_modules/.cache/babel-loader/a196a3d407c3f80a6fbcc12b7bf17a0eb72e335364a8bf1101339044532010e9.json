{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Base Gesture module that provides common functionality for all gesture implementations\n */\n\nimport { eventList } from \"./utils/eventList.js\";\n\n/**\n * The possible phases of a gesture during its lifecycle.\n *\n * - 'start': The gesture has been recognized and is beginning\n * - 'ongoing': The gesture is in progress (e.g., a finger is moving)\n * - 'end': The gesture has completed successfully\n * - 'cancel': The gesture was interrupted or terminated abnormally\n */\n\n/**\n * Core data structure passed to gesture event handlers.\n * Contains all relevant information about a gesture event.\n */\n\n/**\n * Defines the types of pointers that can trigger a gesture.\n */\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for creating a gesture instance.\n */\n\n// eslint-disable-next-line no-underscore-dangle, @typescript-eslint/naming-convention\n\n/**\n * Type for the state of a gesture recognizer.\n */\n\n/**\n * Base abstract class for all gestures. This class provides the fundamental structure\n * and functionality for handling gestures, including registering and unregistering\n * gesture handlers, creating emitters, and managing gesture state.\n *\n * Gesture is designed as an extensible base for implementing specific gesture recognizers.\n * Concrete gesture implementations should extend this class or one of its subclasses.\n *\n * To implement:\n * - Non-pointer gestures (like wheel events): extend this Gesture class directly\n * - Pointer-based gestures: extend the PointerGesture class instead\n *\n * @example\n * ```ts\n * import { Gesture } from './Gesture';\n *\n * class CustomGesture extends Gesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n * }\n * ```\n */\nexport class Gesture {\n  /** Unique name identifying this gesture type */\n\n  /** Whether to prevent default browser action for gesture events */\n\n  /** Whether to stop propagation of gesture events */\n\n  /**\n   * List of gesture names that should prevent this gesture from activating when they are active.\n   */\n\n  /**\n   * Array of keyboard keys that must be pressed for the gesture to be recognized.\n   */\n\n  /**\n   * KeyboardManager instance for tracking key presses\n   */\n\n  /**\n   * List of pointer types that can trigger this gesture.\n   * If undefined, all pointer types are allowed.\n   */\n\n  /**\n   * Pointer mode-specific configuration overrides.\n   */\n\n  /**\n   * User-mutable data object for sharing state between gesture events\n   * This object is included in all events emitted by this gesture\n   */\n  customData = {};\n\n  /** Reference to the singleton PointerManager instance */\n\n  /** Reference to the singleton ActiveGesturesRegistry instance */\n\n  /** The DOM element this gesture is attached to */\n\n  /** Stores the active gesture state */\n\n  /** @internal For types. If false enables phases (xStart, x, xEnd) */\n\n  /** @internal For types. The event type this gesture is associated with */\n\n  /** @internal For types. The options type for this gesture */\n\n  /** @internal For types. The options that can be changed at runtime */\n\n  /** @internal For types. The state that can be changed at runtime */\n\n  /**\n   * Create a new gesture instance with the specified options\n   *\n   * @param options - Configuration options for this gesture\n   */\n  constructor(options) {\n    if (!options || !options.name) {\n      throw new Error('Gesture must be initialized with a valid name.');\n    }\n    if (options.name in eventList) {\n      throw new Error(`Gesture can't be created with a native event name. Tried to use \"${options.name}\". Please use a custom name instead.`);\n    }\n    this.name = options.name;\n    this.preventDefault = options.preventDefault ?? false;\n    this.stopPropagation = options.stopPropagation ?? false;\n    this.preventIf = options.preventIf ?? [];\n    this.requiredKeys = options.requiredKeys ?? [];\n    this.pointerMode = options.pointerMode ?? [];\n    this.pointerOptions = options.pointerOptions ?? {};\n  }\n\n  /**\n   * Initialize the gesture by acquiring the pointer manager and gestures registry\n   * Must be called before the gesture can be used\n   */\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    this.element = element;\n    this.pointerManager = pointerManager;\n    this.gesturesRegistry = gestureRegistry;\n    this.keyboardManager = keyboardManager;\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.addEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.addEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Handle option change events\n   * @param event Custom event with new options in the detail property\n   */\n  handleOptionsChange = event => {\n    if (event && event.detail) {\n      this.updateOptions(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture options with new values\n   * @param options Object containing properties to update\n   */\n  updateOptions(options) {\n    // Update common options\n    this.preventDefault = options.preventDefault ?? this.preventDefault;\n    this.stopPropagation = options.stopPropagation ?? this.stopPropagation;\n    this.preventIf = options.preventIf ?? this.preventIf;\n    this.requiredKeys = options.requiredKeys ?? this.requiredKeys;\n    this.pointerMode = options.pointerMode ?? this.pointerMode;\n    this.pointerOptions = options.pointerOptions ?? this.pointerOptions;\n  }\n\n  /**\n   * Get the default configuration for the pointer specific options.\n   * Change this function in child classes to provide different defaults.\n   */\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys\n    };\n  }\n\n  /**\n   * Get the effective configuration for a specific pointer mode.\n   * This merges the base configuration with pointer mode-specific overrides.\n   *\n   * @param pointerType - The pointer type to get configuration for\n   * @returns The effective configuration object\n   */\n  getEffectiveConfig(pointerType, baseConfig) {\n    if (pointerType !== 'mouse' && pointerType !== 'touch' && pointerType !== 'pen') {\n      // Unknown pointer type, return base config\n      return baseConfig;\n    }\n\n    // Apply pointer mode-specific overrides\n    const pointerModeOverrides = this.pointerOptions[pointerType];\n    if (pointerModeOverrides) {\n      return _extends({}, baseConfig, pointerModeOverrides);\n    }\n    return baseConfig;\n  }\n\n  /**\n   * Handle state change events\n   * @param event Custom event with new state values in the detail property\n   */\n  handleStateChange = event => {\n    if (event && event.detail) {\n      this.updateState(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture state with new values\n   * @param stateChanges Object containing state properties to update\n   */\n  updateState(stateChanges) {\n    // This is a base implementation - concrete gesture classes should override\n    // to handle specific state updates based on their state structure\n    Object.assign(this.state, stateChanges);\n  }\n\n  /**\n   * Create a deep clone of this gesture for a new element\n   *\n   * @param overrides - Optional configuration options that override the defaults\n   * @returns A new instance of this gesture with the same configuration and any overrides applied\n   */\n\n  /**\n   * Check if the event's target is or is contained within any of our registered elements\n   *\n   * @param event - The browser event to check\n   * @returns The matching element or null if no match is found\n   */\n  getTargetElement(event) {\n    if (this.isActive || this.element === event.target || 'contains' in this.element && this.element.contains(event.target) || 'getRootNode' in this.element && this.element.getRootNode() instanceof ShadowRoot && event.composedPath().includes(this.element)) {\n      return this.element;\n    }\n    return null;\n  }\n\n  /** Whether the gesture is currently active */\n  set isActive(isActive) {\n    if (isActive) {\n      this.gesturesRegistry.registerActiveGesture(this.element, this);\n    } else {\n      this.gesturesRegistry.unregisterActiveGesture(this.element, this);\n    }\n  }\n\n  /** Whether the gesture is currently active */\n  get isActive() {\n    return this.gesturesRegistry.isGestureActive(this.element, this) ?? false;\n  }\n\n  /**\n   * Checks if this gesture should be prevented from activating.\n   *\n   * @param element - The DOM element to check against\n   * @param pointerType - The type of pointer triggering the gesture\n   * @returns true if the gesture should be prevented, false otherwise\n   */\n  shouldPreventGesture(element, pointerType) {\n    // Get effective configuration for this pointer type\n    const effectiveConfig = this.getEffectiveConfig(pointerType, this.getBaseConfig());\n\n    // First check if required keyboard keys are pressed\n    if (!this.keyboardManager.areKeysPressed(effectiveConfig.requiredKeys)) {\n      return true; // Prevent the gesture if required keys are not pressed\n    }\n    if (this.preventIf.length === 0) {\n      return false; // No prevention rules, allow the gesture\n    }\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Check if any of the gestures that would prevent this one are active\n    return this.preventIf.some(gestureName => activeGestures[gestureName]);\n  }\n\n  /**\n   * Checks if the given pointer type is allowed for this gesture based on the pointerMode setting.\n   *\n   * @param pointerType - The type of pointer to check.\n   * @returns true if the pointer type is allowed, false otherwise.\n   */\n  isPointerTypeAllowed(pointerType) {\n    // If no pointer mode is specified, all pointer types are allowed\n    if (!this.pointerMode || this.pointerMode.length === 0) {\n      return true;\n    }\n\n    // Check if the pointer type is in the allowed types list\n    return this.pointerMode.includes(pointerType);\n  }\n\n  /**\n   * Clean up the gesture and unregister any listeners\n   * Call this method when the gesture is no longer needed to prevent memory leaks\n   */\n  destroy() {\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.removeEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.removeEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Reset the gesture state to its initial values\n   */\n}","map":{"version":3,"names":["_extends","eventList","Gesture","customData","constructor","options","name","Error","preventDefault","stopPropagation","preventIf","requiredKeys","pointerMode","pointerOptions","init","element","pointerManager","gestureRegistry","keyboardManager","gesturesRegistry","changeOptionsEventName","addEventListener","handleOptionsChange","changeStateEventName","handleStateChange","event","detail","updateOptions","getBaseConfig","getEffectiveConfig","pointerType","baseConfig","pointerModeOverrides","updateState","stateChanges","Object","assign","state","getTargetElement","isActive","target","contains","getRootNode","ShadowRoot","composedPath","includes","registerActiveGesture","unregisterActiveGesture","isGestureActive","shouldPreventGesture","effectiveConfig","areKeysPressed","length","activeGestures","getActiveGestures","some","gestureName","isPointerTypeAllowed","destroy","removeEventListener"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/Gesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Base Gesture module that provides common functionality for all gesture implementations\n */\n\nimport { eventList } from \"./utils/eventList.js\";\n\n/**\n * The possible phases of a gesture during its lifecycle.\n *\n * - 'start': The gesture has been recognized and is beginning\n * - 'ongoing': The gesture is in progress (e.g., a finger is moving)\n * - 'end': The gesture has completed successfully\n * - 'cancel': The gesture was interrupted or terminated abnormally\n */\n\n/**\n * Core data structure passed to gesture event handlers.\n * Contains all relevant information about a gesture event.\n */\n\n/**\n * Defines the types of pointers that can trigger a gesture.\n */\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for creating a gesture instance.\n */\n\n// eslint-disable-next-line no-underscore-dangle, @typescript-eslint/naming-convention\n\n/**\n * Type for the state of a gesture recognizer.\n */\n\n/**\n * Base abstract class for all gestures. This class provides the fundamental structure\n * and functionality for handling gestures, including registering and unregistering\n * gesture handlers, creating emitters, and managing gesture state.\n *\n * Gesture is designed as an extensible base for implementing specific gesture recognizers.\n * Concrete gesture implementations should extend this class or one of its subclasses.\n *\n * To implement:\n * - Non-pointer gestures (like wheel events): extend this Gesture class directly\n * - Pointer-based gestures: extend the PointerGesture class instead\n *\n * @example\n * ```ts\n * import { Gesture } from './Gesture';\n *\n * class CustomGesture extends Gesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n * }\n * ```\n */\nexport class Gesture {\n  /** Unique name identifying this gesture type */\n\n  /** Whether to prevent default browser action for gesture events */\n\n  /** Whether to stop propagation of gesture events */\n\n  /**\n   * List of gesture names that should prevent this gesture from activating when they are active.\n   */\n\n  /**\n   * Array of keyboard keys that must be pressed for the gesture to be recognized.\n   */\n\n  /**\n   * KeyboardManager instance for tracking key presses\n   */\n\n  /**\n   * List of pointer types that can trigger this gesture.\n   * If undefined, all pointer types are allowed.\n   */\n\n  /**\n   * Pointer mode-specific configuration overrides.\n   */\n\n  /**\n   * User-mutable data object for sharing state between gesture events\n   * This object is included in all events emitted by this gesture\n   */\n  customData = {};\n\n  /** Reference to the singleton PointerManager instance */\n\n  /** Reference to the singleton ActiveGesturesRegistry instance */\n\n  /** The DOM element this gesture is attached to */\n\n  /** Stores the active gesture state */\n\n  /** @internal For types. If false enables phases (xStart, x, xEnd) */\n\n  /** @internal For types. The event type this gesture is associated with */\n\n  /** @internal For types. The options type for this gesture */\n\n  /** @internal For types. The options that can be changed at runtime */\n\n  /** @internal For types. The state that can be changed at runtime */\n\n  /**\n   * Create a new gesture instance with the specified options\n   *\n   * @param options - Configuration options for this gesture\n   */\n  constructor(options) {\n    if (!options || !options.name) {\n      throw new Error('Gesture must be initialized with a valid name.');\n    }\n    if (options.name in eventList) {\n      throw new Error(`Gesture can't be created with a native event name. Tried to use \"${options.name}\". Please use a custom name instead.`);\n    }\n    this.name = options.name;\n    this.preventDefault = options.preventDefault ?? false;\n    this.stopPropagation = options.stopPropagation ?? false;\n    this.preventIf = options.preventIf ?? [];\n    this.requiredKeys = options.requiredKeys ?? [];\n    this.pointerMode = options.pointerMode ?? [];\n    this.pointerOptions = options.pointerOptions ?? {};\n  }\n\n  /**\n   * Initialize the gesture by acquiring the pointer manager and gestures registry\n   * Must be called before the gesture can be used\n   */\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    this.element = element;\n    this.pointerManager = pointerManager;\n    this.gesturesRegistry = gestureRegistry;\n    this.keyboardManager = keyboardManager;\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.addEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.addEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Handle option change events\n   * @param event Custom event with new options in the detail property\n   */\n  handleOptionsChange = event => {\n    if (event && event.detail) {\n      this.updateOptions(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture options with new values\n   * @param options Object containing properties to update\n   */\n  updateOptions(options) {\n    // Update common options\n    this.preventDefault = options.preventDefault ?? this.preventDefault;\n    this.stopPropagation = options.stopPropagation ?? this.stopPropagation;\n    this.preventIf = options.preventIf ?? this.preventIf;\n    this.requiredKeys = options.requiredKeys ?? this.requiredKeys;\n    this.pointerMode = options.pointerMode ?? this.pointerMode;\n    this.pointerOptions = options.pointerOptions ?? this.pointerOptions;\n  }\n\n  /**\n   * Get the default configuration for the pointer specific options.\n   * Change this function in child classes to provide different defaults.\n   */\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys\n    };\n  }\n\n  /**\n   * Get the effective configuration for a specific pointer mode.\n   * This merges the base configuration with pointer mode-specific overrides.\n   *\n   * @param pointerType - The pointer type to get configuration for\n   * @returns The effective configuration object\n   */\n  getEffectiveConfig(pointerType, baseConfig) {\n    if (pointerType !== 'mouse' && pointerType !== 'touch' && pointerType !== 'pen') {\n      // Unknown pointer type, return base config\n      return baseConfig;\n    }\n\n    // Apply pointer mode-specific overrides\n    const pointerModeOverrides = this.pointerOptions[pointerType];\n    if (pointerModeOverrides) {\n      return _extends({}, baseConfig, pointerModeOverrides);\n    }\n    return baseConfig;\n  }\n\n  /**\n   * Handle state change events\n   * @param event Custom event with new state values in the detail property\n   */\n  handleStateChange = event => {\n    if (event && event.detail) {\n      this.updateState(event.detail);\n    }\n  };\n\n  /**\n   * Update the gesture state with new values\n   * @param stateChanges Object containing state properties to update\n   */\n  updateState(stateChanges) {\n    // This is a base implementation - concrete gesture classes should override\n    // to handle specific state updates based on their state structure\n    Object.assign(this.state, stateChanges);\n  }\n\n  /**\n   * Create a deep clone of this gesture for a new element\n   *\n   * @param overrides - Optional configuration options that override the defaults\n   * @returns A new instance of this gesture with the same configuration and any overrides applied\n   */\n\n  /**\n   * Check if the event's target is or is contained within any of our registered elements\n   *\n   * @param event - The browser event to check\n   * @returns The matching element or null if no match is found\n   */\n  getTargetElement(event) {\n    if (this.isActive || this.element === event.target || 'contains' in this.element && this.element.contains(event.target) || 'getRootNode' in this.element && this.element.getRootNode() instanceof ShadowRoot && event.composedPath().includes(this.element)) {\n      return this.element;\n    }\n    return null;\n  }\n\n  /** Whether the gesture is currently active */\n  set isActive(isActive) {\n    if (isActive) {\n      this.gesturesRegistry.registerActiveGesture(this.element, this);\n    } else {\n      this.gesturesRegistry.unregisterActiveGesture(this.element, this);\n    }\n  }\n\n  /** Whether the gesture is currently active */\n  get isActive() {\n    return this.gesturesRegistry.isGestureActive(this.element, this) ?? false;\n  }\n\n  /**\n   * Checks if this gesture should be prevented from activating.\n   *\n   * @param element - The DOM element to check against\n   * @param pointerType - The type of pointer triggering the gesture\n   * @returns true if the gesture should be prevented, false otherwise\n   */\n  shouldPreventGesture(element, pointerType) {\n    // Get effective configuration for this pointer type\n    const effectiveConfig = this.getEffectiveConfig(pointerType, this.getBaseConfig());\n\n    // First check if required keyboard keys are pressed\n    if (!this.keyboardManager.areKeysPressed(effectiveConfig.requiredKeys)) {\n      return true; // Prevent the gesture if required keys are not pressed\n    }\n    if (this.preventIf.length === 0) {\n      return false; // No prevention rules, allow the gesture\n    }\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Check if any of the gestures that would prevent this one are active\n    return this.preventIf.some(gestureName => activeGestures[gestureName]);\n  }\n\n  /**\n   * Checks if the given pointer type is allowed for this gesture based on the pointerMode setting.\n   *\n   * @param pointerType - The type of pointer to check.\n   * @returns true if the pointer type is allowed, false otherwise.\n   */\n  isPointerTypeAllowed(pointerType) {\n    // If no pointer mode is specified, all pointer types are allowed\n    if (!this.pointerMode || this.pointerMode.length === 0) {\n      return true;\n    }\n\n    // Check if the pointer type is in the allowed types list\n    return this.pointerMode.includes(pointerType);\n  }\n\n  /**\n   * Clean up the gesture and unregister any listeners\n   * Call this method when the gesture is no longer needed to prevent memory leaks\n   */\n  destroy() {\n    const changeOptionsEventName = `${this.name}ChangeOptions`;\n    this.element.removeEventListener(changeOptionsEventName, this.handleOptionsChange);\n    const changeStateEventName = `${this.name}ChangeState`;\n    this.element.removeEventListener(changeStateEventName, this.handleStateChange);\n  }\n\n  /**\n   * Reset the gesture state to its initial values\n   */\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}