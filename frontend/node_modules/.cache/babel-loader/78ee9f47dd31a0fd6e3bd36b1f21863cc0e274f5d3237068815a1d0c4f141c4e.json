{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapGesture - Detects tap (quick touch without movement) gestures\n *\n * This gesture tracks simple tap interactions on elements, firing a single event when:\n * - A complete tap is detected (pointerup after brief touch without excessive movement)\n * - The tap is canceled (event.g., moved too far or held too long)\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for TapGesture\n * Extends PointerGestureOptions with tap-specific settings\n */\n\n/**\n * Event data specific to tap gesture events\n * Contains information about the tap location and counts\n */\n\n/**\n * Type definition for the CustomEvent created by TapGesture\n */\n\n/**\n * State tracking for the TapGesture\n */\n\n/**\n * TapGesture class for handling tap interactions\n *\n * This gesture detects when users tap on elements without significant movement,\n * and can recognize single taps, double taps, or other multi-tap sequences.\n */\nexport class TapGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    currentTapCount: 0,\n    lastTapTime: 0,\n    lastPosition: null\n  };\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a tap\n   */\n\n  /**\n   * Number of consecutive taps to detect\n   */\n\n  constructor(options) {\n    super(options);\n    this.maxDistance = options.maxDistance ?? 10;\n    this.taps = options.taps ?? 1;\n  }\n  clone(overrides) {\n    return new TapGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      maxDistance: this.maxDistance,\n      taps: this.taps,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n    this.taps = options.taps ?? this.taps;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = {\n      startCentroid: null,\n      currentTapCount: 0,\n      lastTapTime: 0,\n      lastPosition: null\n    };\n  }\n\n  /**\n   * Handle pointer events for the tap gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (this.shouldPreventGesture(targetElement, event.pointerType) || !this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel the gesture if it was active\n        this.cancelTap(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the tap gesture\n          if (distance > this.maxDistance) {\n            this.cancelTap(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          // For valid tap: increment tap count\n          this.state.currentTapCount += 1;\n\n          // Make sure we have a valid position before firing the tap event\n          const position = this.state.lastPosition || this.state.startCentroid;\n          if (!position) {\n            this.cancelTap(targetElement, relevantPointers, event);\n            return;\n          }\n\n          // Check if we've reached the desired number of taps\n          if (this.state.currentTapCount >= this.taps) {\n            // The complete tap sequence has been detected - fire the tap event\n            this.fireTapEvent(targetElement, relevantPointers, event, position);\n\n            // Reset state after successful tap\n            this.resetState();\n          } else {\n            // Store the time of this tap for multi-tap detection\n            this.state.lastTapTime = event.timeStamp;\n\n            // Reset active state but keep the tap count for multi-tap detection\n            this.isActive = false;\n\n            // For multi-tap detection: keep track of the last tap position\n            // but clear the start centroid to prepare for next tap\n            this.state.startCentroid = null;\n\n            // Start a timeout to reset the tap count if the next tap doesn't come soon enough\n            setTimeout(() => {\n              if (this.state && this.state.currentTapCount > 0 && this.state.currentTapCount < this.taps) {\n                this.state.currentTapCount = 0;\n              }\n            }, 300); // 300ms is a typical double-tap detection window\n          }\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelTap(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Fire the main tap event when a valid tap is detected\n   */\n  fireTapEvent(element, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data for the tap event\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase: 'end',\n      // The tap is complete, so we use 'end' state for the event data\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      tapCount: this.state.currentTapCount,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Dispatch a single 'tap' event (not 'tapStart', 'tapEnd', etc.)\n    const domEvent = new CustomEvent(this.name, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current tap gesture\n   */\n  cancelTap(element, pointers, event) {\n    if (this.state.startCentroid || this.state.lastPosition) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n\n      // Get list of active gestures\n      const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n      // Create custom event data for the cancel event\n      const customEventData = {\n        gestureName: this.name,\n        centroid: position,\n        target: event.target,\n        srcEvent: event,\n        phase: 'cancel',\n        pointers,\n        timeStamp: event.timeStamp,\n        x: position.x,\n        y: position.y,\n        tapCount: this.state.currentTapCount,\n        activeGestures,\n        customData: this.customData\n      };\n\n      // Dispatch a 'tapCancel' event\n      const eventName = createEventName(this.name, 'cancel');\n      const domEvent = new CustomEvent(eventName, {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: customEventData\n      });\n      element.dispatchEvent(domEvent);\n    }\n    this.resetState();\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","calculateCentroid","createEventName","TapGesture","state","startCentroid","currentTapCount","lastTapTime","lastPosition","constructor","options","maxDistance","taps","clone","overrides","name","preventDefault","stopPropagation","minPointers","maxPointers","requiredKeys","pointerMode","preventIf","pointerOptions","structuredClone","destroy","resetState","updateOptions","isActive","handlePointerEvent","pointers","event","pointersArray","Array","from","values","targetElement","getTargetElement","relevantPointers","getRelevantPointers","shouldPreventGesture","pointerType","isWithinPointerCount","cancelTap","type","originalTarget","currentPosition","deltaX","x","deltaY","y","distance","Math","sqrt","position","fireTapEvent","timeStamp","setTimeout","element","activeGestures","gesturesRegistry","getActiveGestures","customEventData","gestureName","centroid","target","srcEvent","phase","tapCount","customData","domEvent","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent","eventName"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/TapGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapGesture - Detects tap (quick touch without movement) gestures\n *\n * This gesture tracks simple tap interactions on elements, firing a single event when:\n * - A complete tap is detected (pointerup after brief touch without excessive movement)\n * - The tap is canceled (event.g., moved too far or held too long)\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for TapGesture\n * Extends PointerGestureOptions with tap-specific settings\n */\n\n/**\n * Event data specific to tap gesture events\n * Contains information about the tap location and counts\n */\n\n/**\n * Type definition for the CustomEvent created by TapGesture\n */\n\n/**\n * State tracking for the TapGesture\n */\n\n/**\n * TapGesture class for handling tap interactions\n *\n * This gesture detects when users tap on elements without significant movement,\n * and can recognize single taps, double taps, or other multi-tap sequences.\n */\nexport class TapGesture extends PointerGesture {\n  state = {\n    startCentroid: null,\n    currentTapCount: 0,\n    lastTapTime: 0,\n    lastPosition: null\n  };\n\n  /**\n   * Maximum distance a pointer can move for a gesture to still be considered a tap\n   */\n\n  /**\n   * Number of consecutive taps to detect\n   */\n\n  constructor(options) {\n    super(options);\n    this.maxDistance = options.maxDistance ?? 10;\n    this.taps = options.taps ?? 1;\n  }\n  clone(overrides) {\n    return new TapGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      maxDistance: this.maxDistance,\n      taps: this.taps,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.maxDistance = options.maxDistance ?? this.maxDistance;\n    this.taps = options.taps ?? this.taps;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = {\n      startCentroid: null,\n      currentTapCount: 0,\n      lastTapTime: 0,\n      lastPosition: null\n    };\n  }\n\n  /**\n   * Handle pointer events for the tap gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (this.shouldPreventGesture(targetElement, event.pointerType) || !this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // Cancel the gesture if it was active\n        this.cancelTap(targetElement, relevantPointers, event);\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive) {\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastPosition = _extends({}, this.state.startCentroid);\n          this.isActive = true;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (this.isActive && this.state.startCentroid) {\n          // Calculate current position\n          const currentPosition = calculateCentroid(relevantPointers);\n          this.state.lastPosition = currentPosition;\n\n          // Calculate distance from start position\n          const deltaX = currentPosition.x - this.state.startCentroid.x;\n          const deltaY = currentPosition.y - this.state.startCentroid.y;\n          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n          // If moved too far, cancel the tap gesture\n          if (distance > this.maxDistance) {\n            this.cancelTap(targetElement, relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n        if (this.isActive) {\n          // For valid tap: increment tap count\n          this.state.currentTapCount += 1;\n\n          // Make sure we have a valid position before firing the tap event\n          const position = this.state.lastPosition || this.state.startCentroid;\n          if (!position) {\n            this.cancelTap(targetElement, relevantPointers, event);\n            return;\n          }\n\n          // Check if we've reached the desired number of taps\n          if (this.state.currentTapCount >= this.taps) {\n            // The complete tap sequence has been detected - fire the tap event\n            this.fireTapEvent(targetElement, relevantPointers, event, position);\n\n            // Reset state after successful tap\n            this.resetState();\n          } else {\n            // Store the time of this tap for multi-tap detection\n            this.state.lastTapTime = event.timeStamp;\n\n            // Reset active state but keep the tap count for multi-tap detection\n            this.isActive = false;\n\n            // For multi-tap detection: keep track of the last tap position\n            // but clear the start centroid to prepare for next tap\n            this.state.startCentroid = null;\n\n            // Start a timeout to reset the tap count if the next tap doesn't come soon enough\n            setTimeout(() => {\n              if (this.state && this.state.currentTapCount > 0 && this.state.currentTapCount < this.taps) {\n                this.state.currentTapCount = 0;\n              }\n            }, 300); // 300ms is a typical double-tap detection window\n          }\n        }\n        break;\n      case 'pointercancel':\n      case 'forceCancel':\n        // Cancel the gesture\n        this.cancelTap(targetElement, relevantPointers, event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Fire the main tap event when a valid tap is detected\n   */\n  fireTapEvent(element, pointers, event, position) {\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data for the tap event\n    const customEventData = {\n      gestureName: this.name,\n      centroid: position,\n      target: event.target,\n      srcEvent: event,\n      phase: 'end',\n      // The tap is complete, so we use 'end' state for the event data\n      pointers,\n      timeStamp: event.timeStamp,\n      x: position.x,\n      y: position.y,\n      tapCount: this.state.currentTapCount,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Dispatch a single 'tap' event (not 'tapStart', 'tapEnd', etc.)\n    const domEvent = new CustomEvent(this.name, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current tap gesture\n   */\n  cancelTap(element, pointers, event) {\n    if (this.state.startCentroid || this.state.lastPosition) {\n      const position = this.state.lastPosition || this.state.startCentroid;\n\n      // Get list of active gestures\n      const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n      // Create custom event data for the cancel event\n      const customEventData = {\n        gestureName: this.name,\n        centroid: position,\n        target: event.target,\n        srcEvent: event,\n        phase: 'cancel',\n        pointers,\n        timeStamp: event.timeStamp,\n        x: position.x,\n        y: position.y,\n        tapCount: this.state.currentTapCount,\n        activeGestures,\n        customData: this.customData\n      };\n\n      // Dispatch a 'tapCancel' event\n      const eventName = createEventName(this.name, 'cancel');\n      const domEvent = new CustomEvent(eventName, {\n        bubbles: true,\n        cancelable: true,\n        composed: true,\n        detail: customEventData\n      });\n      element.dispatchEvent(domEvent);\n    }\n    this.resetState();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}