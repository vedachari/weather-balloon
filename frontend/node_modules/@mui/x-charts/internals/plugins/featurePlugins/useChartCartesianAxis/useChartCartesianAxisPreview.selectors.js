"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectorChartPreviewYScales = exports.selectorChartPreviewXScales = exports.selectorChartPreviewComputedYAxis = exports.selectorChartPreviewComputedXAxis = void 0;
var _selectors = require("../../utils/selectors");
var _useChartCartesianAxisLayout = require("./useChartCartesianAxisLayout.selectors");
var _useChartSeries = require("../../corePlugins/useChartSeries");
var _computeAxisValue = require("./computeAxisValue");
var _useChartCartesianAxisRendering = require("./useChartCartesianAxisRendering.selectors");
var _useChartDimensions = require("../../corePlugins/useChartDimensions");
var _constants = require("../../../constants");
var _getAxisScale = require("./getAxisScale");
var _zoom = require("./zoom");
var _scaleGuards = require("../../../scaleGuards");
function createPreviewDrawingArea(axisDirection, mainChartDrawingArea) {
  return axisDirection === 'x' ? {
    left: 0,
    top: 0,
    width: mainChartDrawingArea.width,
    height: _constants.ZOOM_SLIDER_PREVIEW_SIZE,
    right: mainChartDrawingArea.width,
    bottom: _constants.ZOOM_SLIDER_PREVIEW_SIZE
  } : {
    left: 0,
    top: 0,
    width: _constants.ZOOM_SLIDER_PREVIEW_SIZE,
    height: mainChartDrawingArea.height,
    right: _constants.ZOOM_SLIDER_PREVIEW_SIZE,
    bottom: mainChartDrawingArea.height
  };
}
const selectorChartPreviewXScales = exports.selectorChartPreviewXScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartDimensions.selectorChartDrawingArea, _useChartCartesianAxisRendering.selectorChartZoomOptionsLookup, _useChartCartesianAxisRendering.selectorChartNormalizedXScales, (_, axisId) => axisId], function selectorChartPreviewXScales(xAxes, chartDrawingArea, zoomOptions, normalizedXScales, axisId) {
  const hasAxis = xAxes?.some(axis => axis.id === axisId);
  const drawingArea = createPreviewDrawingArea(hasAxis ? 'x' : 'y', chartDrawingArea);
  const options = zoomOptions[axisId];
  const scales = {};
  xAxes?.forEach(eachAxis => {
    const axis = eachAxis;
    const scale = normalizedXScales[axis.id].copy();
    const range = (0, _getAxisScale.getRange)(drawingArea, 'x', axis);
    const zoomedRange = (0, _zoom.zoomScaleRange)(range, [options.minStart, options.maxEnd]);
    scale.range(zoomedRange);
    scales[axis.id] = scale;
  });
  return scales;
});
const selectorChartPreviewComputedXAxis = exports.selectorChartPreviewComputedXAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, _useChartCartesianAxisRendering.selectorChartZoomOptionsLookup, _useChartDimensions.selectorChartDrawingArea, selectorChartPreviewXScales, _useChartCartesianAxisRendering.selectorChartXDomains, (_, axisId) => axisId], (xAxes, formattedSeries, seriesConfig, zoomOptions, chartDrawingArea, scales, domains, axisId) => {
  const hasAxis = xAxes?.some(axis => axis.id === axisId);
  const drawingArea = createPreviewDrawingArea(hasAxis ? 'x' : 'y', chartDrawingArea);
  const options = zoomOptions[axisId];
  const zoomMap = new Map([[axisId, {
    axisId,
    start: options.minStart,
    end: options.maxEnd
  }]]);
  const computedAxes = (0, _computeAxisValue.computeAxisValue)({
    scales,
    drawingArea,
    formattedSeries,
    axis: xAxes,
    seriesConfig,
    axisDirection: 'x',
    zoomMap,
    domains
  });
  if (computedAxes.axis[axisId]) {
    return {
      [axisId]: computedAxes.axis[axisId]
    };
  }
  return computedAxes.axis;
});
const selectorChartPreviewYScales = exports.selectorChartPreviewYScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartDimensions.selectorChartDrawingArea, _useChartCartesianAxisRendering.selectorChartZoomOptionsLookup, _useChartCartesianAxisRendering.selectorChartNormalizedYScales, (_, axisId) => axisId], function selectorChartPreviewYScales(yAxes, chartDrawingArea, zoomOptions, normalizedYScales, axisId) {
  const hasAxis = yAxes?.some(axis => axis.id === axisId);
  const drawingArea = createPreviewDrawingArea(hasAxis ? 'y' : 'x', chartDrawingArea);
  const options = zoomOptions[axisId];
  const scales = {};
  yAxes?.forEach(eachAxis => {
    const axis = eachAxis;
    const scale = normalizedYScales[axis.id].copy();
    let range = (0, _getAxisScale.getRange)(drawingArea, 'y', axis);
    if ((0, _scaleGuards.isOrdinalScale)(scale)) {
      range = range.reverse();
    }
    const zoomedRange = (0, _zoom.zoomScaleRange)(range, [options.minStart, options.maxEnd]);
    scale.range(zoomedRange);
    scales[axis.id] = scale;
  });
  return scales;
});
const selectorChartPreviewComputedYAxis = exports.selectorChartPreviewComputedYAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, _useChartCartesianAxisRendering.selectorChartZoomOptionsLookup, _useChartDimensions.selectorChartDrawingArea, selectorChartPreviewYScales, _useChartCartesianAxisRendering.selectorChartYDomains, (_, axisId) => axisId], (yAxes, formattedSeries, seriesConfig, zoomOptions, chartDrawingArea, scales, domains, axisId) => {
  const hasAxis = yAxes?.some(axis => axis.id === axisId);
  const drawingArea = createPreviewDrawingArea(hasAxis ? 'y' : 'x', chartDrawingArea);
  const options = zoomOptions[axisId];
  const zoomMap = new Map([[axisId, {
    axisId,
    start: options.minStart,
    end: options.maxEnd
  }]]);
  const computedAxes = (0, _computeAxisValue.computeAxisValue)({
    scales,
    drawingArea,
    formattedSeries,
    axis: yAxes,
    seriesConfig,
    axisDirection: 'y',
    zoomMap,
    domains
  });
  if (computedAxes.axis[axisId]) {
    return {
      [axisId]: computedAxes.axis[axisId]
    };
  }
  return computedAxes.axis;
});