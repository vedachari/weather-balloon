{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressAndDragGesture - Detects press followed by drag gestures using composition\n *\n * This gesture uses internal PressGesture and PanGesture instances to:\n * 1. First, detect a press (hold for specified duration without movement)\n * 2. Then, track drag movements from the press position\n *\n * The gesture fires events when:\n * - A press is completed (press phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n *\n * This is ideal for panning operations where you want to hold first, then drag.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { PressGesture } from \"./PressGesture.js\";\n\n/**\n * Configuration options for PressAndDragGesture\n * Extends PointerGestureOptions with press and drag specific settings\n */\n\n/**\n * Event data specific to press and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by PressAndDragGesture\n */\n\n/**\n * Represents the current phase of the PressAndDrag gesture\n */\n\n/**\n * State tracking for the PressAndDragGesture\n */\n\n/**\n * PressAndDragGesture class for handling press followed by drag interactions\n *\n * This gesture composes press and drag logic patterns from PressGesture and PanGesture\n * into a single coordinated gesture that handles press-then-drag interactions.\n */\nexport class PressAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForPress',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Duration required for press recognition\n   */\n\n  /**\n   * Maximum distance a pointer can move during press for it to still be considered a press\n   */\n\n  /**\n   * Maximum time between press completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.pressDuration = options.pressDuration ?? 500;\n    this.pressMaxDistance = options.pressMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.pressGesture = new PressGesture({\n      name: `${this.name}-press`,\n      duration: this.pressDuration,\n      maxDistance: this.pressMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new PressAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      pressDuration: this.pressDuration,\n      pressMaxDistance: this.pressMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.pressGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n\n    // Listen to press gesture events\n    this.element.addEventListener(this.pressGesture.name, this.pressHandler);\n\n    // Listen to pan gesture events for dragging\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.pressGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.pressGesture.name, this.pressHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.pressDuration = options.pressDuration ?? this.pressDuration;\n    this.pressMaxDistance = options.pressMaxDistance ?? this.pressMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n\n    // Update internal gesture options\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.pressGesture.name}ChangeOptions`, {\n      detail: {\n        duration: this.pressDuration,\n        maxDistance: this.pressMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForPress',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the PressAndDragGesture relies on PressGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  pressHandler = () => {\n    if (this.state.phase !== 'waitingForPress') {\n      return;\n    }\n    this.state.phase = 'pressDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'pressDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n\n    // Restore touch action since we're now dragging\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchmove', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchend', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n    this.element.removeEventListener('touchmove', preventDefault);\n    this.element.removeEventListener('touchend', preventDefault);\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","createEventName","preventDefault","PanGesture","PressGesture","PressAndDragGesture","state","phase","dragTimeoutId","constructor","options","pressDuration","pressMaxDistance","dragTimeout","dragThreshold","dragDirection","pressGesture","name","duration","maxDistance","maxPointers","pointerMode","requiredKeys","preventIf","pointerOptions","structuredClone","panGesture","minPointers","threshold","direction","clone","overrides","stopPropagation","init","element","pointerManager","gestureRegistry","keyboardManager","addEventListener","pressHandler","dragStartHandler","dragMoveHandler","dragEndHandler","destroy","resetState","removeEventListener","updateOptions","dispatchEvent","CustomEvent","detail","clearTimeout","restoreTouchAction","isActive","handlePointerEvent","setTouchAction","setTimeout","event","passive"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/PressAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PressAndDragGesture - Detects press followed by drag gestures using composition\n *\n * This gesture uses internal PressGesture and PanGesture instances to:\n * 1. First, detect a press (hold for specified duration without movement)\n * 2. Then, track drag movements from the press position\n *\n * The gesture fires events when:\n * - A press is completed (press phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n *\n * This is ideal for panning operations where you want to hold first, then drag.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { PressGesture } from \"./PressGesture.js\";\n\n/**\n * Configuration options for PressAndDragGesture\n * Extends PointerGestureOptions with press and drag specific settings\n */\n\n/**\n * Event data specific to press and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by PressAndDragGesture\n */\n\n/**\n * Represents the current phase of the PressAndDrag gesture\n */\n\n/**\n * State tracking for the PressAndDragGesture\n */\n\n/**\n * PressAndDragGesture class for handling press followed by drag interactions\n *\n * This gesture composes press and drag logic patterns from PressGesture and PanGesture\n * into a single coordinated gesture that handles press-then-drag interactions.\n */\nexport class PressAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForPress',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Duration required for press recognition\n   */\n\n  /**\n   * Maximum distance a pointer can move during press for it to still be considered a press\n   */\n\n  /**\n   * Maximum time between press completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.pressDuration = options.pressDuration ?? 500;\n    this.pressMaxDistance = options.pressMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.pressGesture = new PressGesture({\n      name: `${this.name}-press`,\n      duration: this.pressDuration,\n      maxDistance: this.pressMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new PressAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      pressDuration: this.pressDuration,\n      pressMaxDistance: this.pressMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.pressGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n\n    // Listen to press gesture events\n    this.element.addEventListener(this.pressGesture.name, this.pressHandler);\n\n    // Listen to pan gesture events for dragging\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.pressGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.pressGesture.name, this.pressHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.pressDuration = options.pressDuration ?? this.pressDuration;\n    this.pressMaxDistance = options.pressMaxDistance ?? this.pressMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n\n    // Update internal gesture options\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.pressGesture.name}ChangeOptions`, {\n      detail: {\n        duration: this.pressDuration,\n        maxDistance: this.pressMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForPress',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the PressAndDragGesture relies on PressGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  pressHandler = () => {\n    if (this.state.phase !== 'waitingForPress') {\n      return;\n    }\n    this.state.phase = 'pressDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'pressDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n\n    // Restore touch action since we're now dragging\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchmove', preventDefault, {\n      passive: false\n    });\n    this.element.addEventListener('touchend', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n    this.element.removeEventListener('touchmove', preventDefault);\n    this.element.removeEventListener('touchend', preventDefault);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}