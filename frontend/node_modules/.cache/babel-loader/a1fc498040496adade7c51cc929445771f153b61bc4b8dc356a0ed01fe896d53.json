{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PanGesture - Detects panning (dragging) movements\n *\n * This gesture tracks pointer dragging movements across elements, firing events when:\n * - The drag movement begins and passes the threshold distance (start)\n * - The drag movement continues (ongoing)\n * - The drag movement ends (end)\n *\n * The gesture can be configured to recognize movement only in specific directions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName, getDirection, isDirectionAllowed } from \"../utils/index.js\";\n\n/**\n * Configuration options for PanGesture\n * Extends PointerGestureOptions with direction constraints\n */\n\n/**\n * Event data specific to pan gesture events\n * Contains information about movement distance, direction, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PanGesture\n */\n\n/**\n * State tracking for the PanGesture\n */\n\n/**\n * PanGesture class for handling panning/dragging interactions\n *\n * This gesture detects when users drag across elements with one or more pointers,\n * and dispatches directional movement events with delta and velocity information.\n */\nexport class PanGesture extends PointerGesture {\n  state = (() => ({\n    startPointers: new Map(),\n    startCentroid: null,\n    lastCentroid: null,\n    movementThresholdReached: false,\n    totalDeltaX: 0,\n    totalDeltaY: 0,\n    activeDeltaX: 0,\n    activeDeltaY: 0,\n    lastDirection: {\n      vertical: null,\n      horizontal: null,\n      mainAxis: null\n    },\n    lastDeltas: null\n  }))();\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  /**\n   * Allowed directions for the pan gesture\n   * Default allows all directions\n   */\n\n  constructor(options) {\n    super(options);\n    this.direction = options.direction || ['up', 'down', 'left', 'right'];\n    this.threshold = options.threshold || 0;\n  }\n  clone(overrides) {\n    return new PanGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      direction: [...this.direction],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.direction = options.direction || this.direction;\n    this.threshold = options.threshold ?? this.threshold;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startPointers: new Map(),\n      startCentroid: null,\n      lastCentroid: null,\n      lastDeltas: null,\n      activeDeltaX: 0,\n      activeDeltaY: 0,\n      movementThresholdReached: false,\n      lastDirection: {\n        vertical: null,\n        horizontal: null,\n        mainAxis: null\n      }\n    });\n  }\n\n  /**\n   * Handle pointer events for the pan gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active pan gestures when we get a force reset event\n      this.cancel(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      // If the gesture was active but now should be prevented, cancel it gracefully\n      this.cancel(targetElement, pointersArray, event);\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      // Cancel or end the gesture if it was active\n      this.cancel(targetElement, relevantPointers, event);\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Store initial pointers\n          relevantPointers.forEach(pointer => {\n            this.state.startPointers.set(pointer.pointerId, pointer);\n          });\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastCentroid = _extends({}, this.state.startCentroid);\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startCentroid && this.isWithinPointerCount(pointersArray, event.pointerType)) {\n          // Calculate current centroid\n          const currentCentroid = calculateCentroid(relevantPointers);\n\n          // Calculate delta from start\n          const distanceDeltaX = currentCentroid.x - this.state.startCentroid.x;\n          const distanceDeltaY = currentCentroid.y - this.state.startCentroid.y;\n\n          // Calculate movement distance\n          const distance = Math.sqrt(distanceDeltaX * distanceDeltaX + distanceDeltaY * distanceDeltaY);\n\n          // Determine movement direction\n          const moveDirection = getDirection(this.state.lastCentroid ?? this.state.startCentroid, currentCentroid);\n\n          // Calculate change in position since last move\n          const lastDeltaX = this.state.lastCentroid ? currentCentroid.x - this.state.lastCentroid.x : 0;\n          const lastDeltaY = this.state.lastCentroid ? currentCentroid.y - this.state.lastCentroid.y : 0;\n\n          // Check if movement passes the threshold and is in an allowed direction\n          if (!this.state.movementThresholdReached && distance >= this.threshold && isDirectionAllowed(moveDirection, this.direction)) {\n            this.state.movementThresholdReached = true;\n            this.isActive = true;\n\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit start event\n            this.emitPanEvent(targetElement, 'start', relevantPointers, event, currentCentroid);\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n          // If we've already crossed the threshold, continue tracking\n          else if (this.state.movementThresholdReached && this.isActive) {\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit ongoing event\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n\n          // Update last centroid\n          this.state.lastCentroid = currentCentroid;\n          this.state.lastDirection = moveDirection;\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        // If the gesture was active (threshold was reached), emit end event\n        if (this.isActive && this.state.movementThresholdReached) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            // End the gesture\n            const currentCentroid = this.state.lastCentroid || this.state.startCentroid;\n            if (event.type === 'pointercancel') {\n              this.emitPanEvent(targetElement, 'cancel', relevantPointers, event, currentCentroid);\n            }\n            this.emitPanEvent(targetElement, 'end', relevantPointers, event, currentCentroid);\n            this.resetState();\n          }\n        } else {\n          this.resetState();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pan-specific events with additional data\n   */\n  emitPanEvent(element, phase, pointers, event, currentCentroid) {\n    if (!this.state.startCentroid) {\n      return;\n    }\n    const deltaX = this.state.lastDeltas?.x ?? 0;\n    const deltaY = this.state.lastDeltas?.y ?? 0;\n\n    // Calculate velocity - time difference in seconds\n    const firstPointer = this.state.startPointers.values().next().value;\n    const timeElapsed = firstPointer ? (event.timeStamp - firstPointer.timeStamp) / 1000 : 0;\n    const velocityX = timeElapsed > 0 ? deltaX / timeElapsed : 0;\n    const velocityY = timeElapsed > 0 ? deltaY / timeElapsed : 0;\n    const velocity = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      initialCentroid: this.state.startCentroid,\n      centroid: currentCentroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      deltaX,\n      deltaY,\n      direction: this.state.lastDirection,\n      velocityX,\n      velocityY,\n      velocity,\n      totalDeltaX: this.state.totalDeltaX,\n      totalDeltaY: this.state.totalDeltaY,\n      activeDeltaX: this.state.activeDeltaX,\n      activeDeltaY: this.state.activeDeltaY,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current gesture\n   */\n  cancel(element, pointers, event) {\n    if (this.isActive) {\n      const el = element ?? this.element;\n      this.emitPanEvent(el, 'cancel', pointers, event, this.state.lastCentroid);\n      this.emitPanEvent(el, 'end', pointers, event, this.state.lastCentroid);\n    }\n    this.resetState();\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","calculateCentroid","createEventName","getDirection","isDirectionAllowed","PanGesture","state","startPointers","Map","startCentroid","lastCentroid","movementThresholdReached","totalDeltaX","totalDeltaY","activeDeltaX","activeDeltaY","lastDirection","vertical","horizontal","mainAxis","lastDeltas","constructor","options","direction","threshold","clone","overrides","name","preventDefault","stopPropagation","minPointers","maxPointers","requiredKeys","pointerMode","preventIf","pointerOptions","structuredClone","destroy","resetState","updateOptions","isActive","handlePointerEvent","pointers","event","pointersArray","Array","from","values","type","cancel","target","targetElement","getTargetElement","shouldPreventGesture","pointerType","relevantPointers","getRelevantPointers","isWithinPointerCount","forEach","pointer","set","pointerId","originalTarget","currentCentroid","distanceDeltaX","x","distanceDeltaY","y","distance","Math","sqrt","moveDirection","lastDeltaX","lastDeltaY","emitPanEvent","remainingPointers","filter","p","element","phase","deltaX","deltaY","firstPointer","next","value","timeElapsed","timeStamp","velocityX","velocityY","velocity","activeGestures","gesturesRegistry","getActiveGestures","customEventData","gestureName","initialCentroid","centroid","srcEvent","customData","eventName","domEvent","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent","el"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/PanGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * PanGesture - Detects panning (dragging) movements\n *\n * This gesture tracks pointer dragging movements across elements, firing events when:\n * - The drag movement begins and passes the threshold distance (start)\n * - The drag movement continues (ongoing)\n * - The drag movement ends (end)\n *\n * The gesture can be configured to recognize movement only in specific directions.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, createEventName, getDirection, isDirectionAllowed } from \"../utils/index.js\";\n\n/**\n * Configuration options for PanGesture\n * Extends PointerGestureOptions with direction constraints\n */\n\n/**\n * Event data specific to pan gesture events\n * Contains information about movement distance, direction, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by PanGesture\n */\n\n/**\n * State tracking for the PanGesture\n */\n\n/**\n * PanGesture class for handling panning/dragging interactions\n *\n * This gesture detects when users drag across elements with one or more pointers,\n * and dispatches directional movement events with delta and velocity information.\n */\nexport class PanGesture extends PointerGesture {\n  state = (() => ({\n    startPointers: new Map(),\n    startCentroid: null,\n    lastCentroid: null,\n    movementThresholdReached: false,\n    totalDeltaX: 0,\n    totalDeltaY: 0,\n    activeDeltaX: 0,\n    activeDeltaY: 0,\n    lastDirection: {\n      vertical: null,\n      horizontal: null,\n      mainAxis: null\n    },\n    lastDeltas: null\n  }))();\n\n  /**\n   * Movement threshold in pixels that must be exceeded before the gesture activates.\n   * Higher values reduce false positive gesture detection for small movements.\n   */\n\n  /**\n   * Allowed directions for the pan gesture\n   * Default allows all directions\n   */\n\n  constructor(options) {\n    super(options);\n    this.direction = options.direction || ['up', 'down', 'left', 'right'];\n    this.threshold = options.threshold || 0;\n  }\n  clone(overrides) {\n    return new PanGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      threshold: this.threshold,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      direction: [...this.direction],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.direction = options.direction || this.direction;\n    this.threshold = options.threshold ?? this.threshold;\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startPointers: new Map(),\n      startCentroid: null,\n      lastCentroid: null,\n      lastDeltas: null,\n      activeDeltaX: 0,\n      activeDeltaY: 0,\n      movementThresholdReached: false,\n      lastDirection: {\n        vertical: null,\n        horizontal: null,\n        mainAxis: null\n      }\n    });\n  }\n\n  /**\n   * Handle pointer events for the pan gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Check for our forceCancel event to handle interrupted gestures (from contextmenu, blur)\n    if (event.type === 'forceCancel') {\n      // Reset all active pan gestures when we get a force reset event\n      this.cancel(event.target, pointersArray, event);\n      return;\n    }\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      // If the gesture was active but now should be prevented, cancel it gracefully\n      this.cancel(targetElement, pointersArray, event);\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      // Cancel or end the gesture if it was active\n      this.cancel(targetElement, relevantPointers, event);\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (!this.isActive && !this.state.startCentroid) {\n          // Store initial pointers\n          relevantPointers.forEach(pointer => {\n            this.state.startPointers.set(pointer.pointerId, pointer);\n          });\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n\n          // Calculate and store the starting centroid\n          this.state.startCentroid = calculateCentroid(relevantPointers);\n          this.state.lastCentroid = _extends({}, this.state.startCentroid);\n        }\n        break;\n      case 'pointermove':\n        if (this.state.startCentroid && this.isWithinPointerCount(pointersArray, event.pointerType)) {\n          // Calculate current centroid\n          const currentCentroid = calculateCentroid(relevantPointers);\n\n          // Calculate delta from start\n          const distanceDeltaX = currentCentroid.x - this.state.startCentroid.x;\n          const distanceDeltaY = currentCentroid.y - this.state.startCentroid.y;\n\n          // Calculate movement distance\n          const distance = Math.sqrt(distanceDeltaX * distanceDeltaX + distanceDeltaY * distanceDeltaY);\n\n          // Determine movement direction\n          const moveDirection = getDirection(this.state.lastCentroid ?? this.state.startCentroid, currentCentroid);\n\n          // Calculate change in position since last move\n          const lastDeltaX = this.state.lastCentroid ? currentCentroid.x - this.state.lastCentroid.x : 0;\n          const lastDeltaY = this.state.lastCentroid ? currentCentroid.y - this.state.lastCentroid.y : 0;\n\n          // Check if movement passes the threshold and is in an allowed direction\n          if (!this.state.movementThresholdReached && distance >= this.threshold && isDirectionAllowed(moveDirection, this.direction)) {\n            this.state.movementThresholdReached = true;\n            this.isActive = true;\n\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit start event\n            this.emitPanEvent(targetElement, 'start', relevantPointers, event, currentCentroid);\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n          // If we've already crossed the threshold, continue tracking\n          else if (this.state.movementThresholdReached && this.isActive) {\n            // Update total accumulated delta\n            this.state.lastDeltas = {\n              x: lastDeltaX,\n              y: lastDeltaY\n            };\n            this.state.totalDeltaX += lastDeltaX;\n            this.state.totalDeltaY += lastDeltaY;\n            this.state.activeDeltaX += lastDeltaX;\n            this.state.activeDeltaY += lastDeltaY;\n\n            // Emit ongoing event\n            this.emitPanEvent(targetElement, 'ongoing', relevantPointers, event, currentCentroid);\n          }\n\n          // Update last centroid\n          this.state.lastCentroid = currentCentroid;\n          this.state.lastDirection = moveDirection;\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        // If the gesture was active (threshold was reached), emit end event\n        if (this.isActive && this.state.movementThresholdReached) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            // End the gesture\n            const currentCentroid = this.state.lastCentroid || this.state.startCentroid;\n            if (event.type === 'pointercancel') {\n              this.emitPanEvent(targetElement, 'cancel', relevantPointers, event, currentCentroid);\n            }\n            this.emitPanEvent(targetElement, 'end', relevantPointers, event, currentCentroid);\n            this.resetState();\n          }\n        } else {\n          this.resetState();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit pan-specific events with additional data\n   */\n  emitPanEvent(element, phase, pointers, event, currentCentroid) {\n    if (!this.state.startCentroid) {\n      return;\n    }\n    const deltaX = this.state.lastDeltas?.x ?? 0;\n    const deltaY = this.state.lastDeltas?.y ?? 0;\n\n    // Calculate velocity - time difference in seconds\n    const firstPointer = this.state.startPointers.values().next().value;\n    const timeElapsed = firstPointer ? (event.timeStamp - firstPointer.timeStamp) / 1000 : 0;\n    const velocityX = timeElapsed > 0 ? deltaX / timeElapsed : 0;\n    const velocityY = timeElapsed > 0 ? deltaY / timeElapsed : 0;\n    const velocity = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n\n    // Create custom event data\n    const customEventData = {\n      gestureName: this.name,\n      initialCentroid: this.state.startCentroid,\n      centroid: currentCentroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      deltaX,\n      deltaY,\n      direction: this.state.lastDirection,\n      velocityX,\n      velocityY,\n      velocity,\n      totalDeltaX: this.state.totalDeltaX,\n      totalDeltaY: this.state.totalDeltaY,\n      activeDeltaX: this.state.activeDeltaX,\n      activeDeltaY: this.state.activeDeltaY,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n\n    // Apply preventDefault/stopPropagation if configured\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Cancel the current gesture\n   */\n  cancel(element, pointers, event) {\n    if (this.isActive) {\n      const el = element ?? this.element;\n      this.emitPanEvent(el, 'cancel', pointers, event, this.state.lastCentroid);\n      this.emitPanEvent(el, 'end', pointers, event, this.state.lastCentroid);\n    }\n    this.resetState();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}