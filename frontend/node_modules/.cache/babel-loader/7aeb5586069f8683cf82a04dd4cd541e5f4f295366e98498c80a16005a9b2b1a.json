{"ast":null,"code":"import { Gesture } from \"./Gesture.js\";\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for pointer-based gestures, extending the base GestureOptions.\n *\n * These options provide fine-grained control over how pointer events are interpreted\n * and when the gesture should be recognized.\n */\n\n/**\n * Base class for all pointer-based gestures.\n *\n * This class extends the base Gesture class with specialized functionality for\n * handling pointer events via the PointerManager. It provides common logic for\n * determining when a gesture should activate, tracking pointer movements, and\n * managing pointer thresholds.\n *\n * All pointer-based gesture implementations should extend this class rather than\n * the base Gesture class.\n *\n * @example\n * ```ts\n * import { PointerGesture } from './PointerGesture';\n *\n * class CustomGesture extends PointerGesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n *\n *   handlePointerEvent = (pointers, event) => {\n *     // Handle pointer events here\n *   }\n * }\n * ```\n */\nexport class PointerGesture extends Gesture {\n  /** Function to unregister from the PointerManager when destroying this gesture */\n  unregisterHandler = null;\n\n  /** The original target element when the gesture began, used to prevent limbo state if target is removed */\n  originalTarget = null;\n\n  /**\n   * Minimum number of simultaneous pointers required to activate the gesture.\n   * The gesture will not start until at least this many pointers are active.\n   */\n\n  /**\n   * Maximum number of simultaneous pointers allowed for this gesture.\n   * If more than this many pointers are detected, the gesture may be canceled.\n   */\n\n  constructor(options) {\n    super(options);\n    this.minPointers = options.minPointers ?? 1;\n    this.maxPointers = options.maxPointers ?? Infinity;\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.unregisterHandler = this.pointerManager.registerGestureHandler(this.handlePointerEvent);\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.minPointers = options.minPointers ?? this.minPointers;\n    this.maxPointers = options.maxPointers ?? this.maxPointers;\n  }\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers\n    };\n  }\n  isWithinPointerCount(pointers, pointerMode) {\n    const config = this.getEffectiveConfig(pointerMode, this.getBaseConfig());\n    return pointers.length >= config.minPointers && pointers.length <= config.maxPointers;\n  }\n\n  /**\n   * Handler for pointer events from the PointerManager.\n   * Concrete gesture implementations must override this method to provide\n   * gesture-specific logic for recognizing and tracking the gesture.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param event - The original pointer event from the browser\n   */\n\n  /**\n   * Calculate the target element for the gesture based on the active pointers.\n   *\n   * It takes into account the original target element.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param calculatedTarget - The target element calculated from getTargetElement\n   * @returns A list of relevant pointers for this gesture\n   */\n  getRelevantPointers(pointers, calculatedTarget) {\n    return pointers.filter(pointer => this.isPointerTypeAllowed(pointer.pointerType) && (calculatedTarget === pointer.target || pointer.target === this.originalTarget || calculatedTarget === this.originalTarget || 'contains' in calculatedTarget && calculatedTarget.contains(pointer.target)) || 'getRootNode' in calculatedTarget && calculatedTarget.getRootNode() instanceof ShadowRoot && pointer.srcEvent.composedPath().includes(calculatedTarget));\n  }\n  destroy() {\n    if (this.unregisterHandler) {\n      this.unregisterHandler();\n      this.unregisterHandler = null;\n    }\n    super.destroy();\n  }\n}","map":{"version":3,"names":["Gesture","PointerGesture","unregisterHandler","originalTarget","constructor","options","minPointers","maxPointers","Infinity","init","element","pointerManager","gestureRegistry","keyboardManager","registerGestureHandler","handlePointerEvent","updateOptions","getBaseConfig","requiredKeys","isWithinPointerCount","pointers","pointerMode","config","getEffectiveConfig","length","getRelevantPointers","calculatedTarget","filter","pointer","isPointerTypeAllowed","pointerType","target","contains","getRootNode","ShadowRoot","srcEvent","composedPath","includes","destroy"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/PointerGesture.js"],"sourcesContent":["import { Gesture } from \"./Gesture.js\";\n\n/**\n * Base configuration options that can be overridden per pointer mode.\n */\n\n/**\n * Configuration options for pointer-based gestures, extending the base GestureOptions.\n *\n * These options provide fine-grained control over how pointer events are interpreted\n * and when the gesture should be recognized.\n */\n\n/**\n * Base class for all pointer-based gestures.\n *\n * This class extends the base Gesture class with specialized functionality for\n * handling pointer events via the PointerManager. It provides common logic for\n * determining when a gesture should activate, tracking pointer movements, and\n * managing pointer thresholds.\n *\n * All pointer-based gesture implementations should extend this class rather than\n * the base Gesture class.\n *\n * @example\n * ```ts\n * import { PointerGesture } from './PointerGesture';\n *\n * class CustomGesture extends PointerGesture {\n *   constructor(options) {\n *     super(options);\n *   }\n *\n *   clone(overrides) {\n *     return new CustomGesture({\n *       name: this.name,\n *       // ... other options\n *       ...overrides,\n *     });\n *   }\n *\n *   handlePointerEvent = (pointers, event) => {\n *     // Handle pointer events here\n *   }\n * }\n * ```\n */\nexport class PointerGesture extends Gesture {\n  /** Function to unregister from the PointerManager when destroying this gesture */\n  unregisterHandler = null;\n\n  /** The original target element when the gesture began, used to prevent limbo state if target is removed */\n  originalTarget = null;\n\n  /**\n   * Minimum number of simultaneous pointers required to activate the gesture.\n   * The gesture will not start until at least this many pointers are active.\n   */\n\n  /**\n   * Maximum number of simultaneous pointers allowed for this gesture.\n   * If more than this many pointers are detected, the gesture may be canceled.\n   */\n\n  constructor(options) {\n    super(options);\n    this.minPointers = options.minPointers ?? 1;\n    this.maxPointers = options.maxPointers ?? Infinity;\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.unregisterHandler = this.pointerManager.registerGestureHandler(this.handlePointerEvent);\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.minPointers = options.minPointers ?? this.minPointers;\n    this.maxPointers = options.maxPointers ?? this.maxPointers;\n  }\n  getBaseConfig() {\n    return {\n      requiredKeys: this.requiredKeys,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers\n    };\n  }\n  isWithinPointerCount(pointers, pointerMode) {\n    const config = this.getEffectiveConfig(pointerMode, this.getBaseConfig());\n    return pointers.length >= config.minPointers && pointers.length <= config.maxPointers;\n  }\n\n  /**\n   * Handler for pointer events from the PointerManager.\n   * Concrete gesture implementations must override this method to provide\n   * gesture-specific logic for recognizing and tracking the gesture.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param event - The original pointer event from the browser\n   */\n\n  /**\n   * Calculate the target element for the gesture based on the active pointers.\n   *\n   * It takes into account the original target element.\n   *\n   * @param pointers - Map of active pointers by pointer ID\n   * @param calculatedTarget - The target element calculated from getTargetElement\n   * @returns A list of relevant pointers for this gesture\n   */\n  getRelevantPointers(pointers, calculatedTarget) {\n    return pointers.filter(pointer => this.isPointerTypeAllowed(pointer.pointerType) && (calculatedTarget === pointer.target || pointer.target === this.originalTarget || calculatedTarget === this.originalTarget || 'contains' in calculatedTarget && calculatedTarget.contains(pointer.target)) || 'getRootNode' in calculatedTarget && calculatedTarget.getRootNode() instanceof ShadowRoot && pointer.srcEvent.composedPath().includes(calculatedTarget));\n  }\n  destroy() {\n    if (this.unregisterHandler) {\n      this.unregisterHandler();\n      this.unregisterHandler = null;\n    }\n    super.destroy();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}