{"ast":null,"code":"import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from './constants.js';\nimport { Encoding } from './encoding.js';\nimport { float32, float64, int32, isLittleEndian } from './utils.js';\nexport class ByteBuffer {\n  /**\n   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n   */\n  constructor(bytes_) {\n    this.bytes_ = bytes_;\n    this.position_ = 0;\n    this.text_decoder_ = new TextDecoder();\n  }\n  /**\n   * Create and allocate a new ByteBuffer with a given size.\n   */\n  static allocate(byte_size) {\n    return new ByteBuffer(new Uint8Array(byte_size));\n  }\n  clear() {\n    this.position_ = 0;\n  }\n  /**\n   * Get the underlying `Uint8Array`.\n   */\n  bytes() {\n    return this.bytes_;\n  }\n  /**\n   * Get the buffer's position.\n   */\n  position() {\n    return this.position_;\n  }\n  /**\n   * Set the buffer's position.\n   */\n  setPosition(position) {\n    this.position_ = position;\n  }\n  /**\n   * Get the buffer's capacity.\n   */\n  capacity() {\n    return this.bytes_.length;\n  }\n  readInt8(offset) {\n    return this.readUint8(offset) << 24 >> 24;\n  }\n  readUint8(offset) {\n    return this.bytes_[offset];\n  }\n  readInt16(offset) {\n    return this.readUint16(offset) << 16 >> 16;\n  }\n  readUint16(offset) {\n    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n  }\n  readInt32(offset) {\n    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n  }\n  readUint32(offset) {\n    return this.readInt32(offset) >>> 0;\n  }\n  readInt64(offset) {\n    return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n  }\n  readUint64(offset) {\n    return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n  }\n  readFloat32(offset) {\n    int32[0] = this.readInt32(offset);\n    return float32[0];\n  }\n  readFloat64(offset) {\n    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n    return float64[0];\n  }\n  writeInt8(offset, value) {\n    this.bytes_[offset] = value;\n  }\n  writeUint8(offset, value) {\n    this.bytes_[offset] = value;\n  }\n  writeInt16(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n  }\n  writeUint16(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n  }\n  writeInt32(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n  }\n  writeUint32(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n  }\n  writeInt64(offset, value) {\n    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n  }\n  writeUint64(offset, value) {\n    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n    this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n  }\n  writeFloat32(offset, value) {\n    float32[0] = value;\n    this.writeInt32(offset, int32[0]);\n  }\n  writeFloat64(offset, value) {\n    float64[0] = value;\n    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n  }\n  /**\n   * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n   * schema does not include a file_identifier (likely points at padding or the\n   * start of a the root vtable).\n   */\n  getBufferIdentifier() {\n    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n    }\n    let result = '';\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n    }\n    return result;\n  }\n  /**\n   * Look up a field in the vtable, return an offset into the object, or 0 if the\n   * field is not present.\n   */\n  __offset(bb_pos, vtable_offset) {\n    const vtable = bb_pos - this.readInt32(bb_pos);\n    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n  }\n  /**\n   * Initialize any Table-derived type to point to the union at the given offset.\n   */\n  __union(t, offset) {\n    t.bb_pos = offset + this.readInt32(offset);\n    t.bb = this;\n    return t;\n  }\n  /**\n   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n   * This allocates a new string and converts to wide chars upon each access.\n   *\n   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n   * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n   * the data will just be packaged back up in another FlatBuffer later on.\n   *\n   * @param offset\n   * @param opt_encoding Defaults to UTF16_STRING\n   */\n  __string(offset, opt_encoding) {\n    offset += this.readInt32(offset);\n    const length = this.readInt32(offset);\n    offset += SIZEOF_INT;\n    const utf8bytes = this.bytes_.subarray(offset, offset + length);\n    if (opt_encoding === Encoding.UTF8_BYTES) return utf8bytes;else return this.text_decoder_.decode(utf8bytes);\n  }\n  /**\n   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n   * if a string then return a new one\n   *\n   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n   * makes the behaviour of __union_with_string different compared to __union\n   */\n  __union_with_string(o, offset) {\n    if (typeof o === 'string') {\n      return this.__string(offset);\n    }\n    return this.__union(o, offset);\n  }\n  /**\n   * Retrieve the relative offset stored at \"offset\"\n   */\n  __indirect(offset) {\n    return offset + this.readInt32(offset);\n  }\n  /**\n   * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector(offset) {\n    return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n  }\n  /**\n   * Get the length of a vector whose offset is stored at \"offset\" in this object.\n   */\n  __vector_len(offset) {\n    return this.readInt32(offset + this.readInt32(offset));\n  }\n  __has_identifier(ident) {\n    if (ident.length != FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n    }\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * A helper function for generating list for obj api\n   */\n  createScalarList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val);\n      }\n    }\n    return ret;\n  }\n  /**\n   * A helper function for generating list for obj api\n   * @param listAccessor function that accepts an index and return data at that index\n   * @param listLength listLength\n   * @param res result list\n   */\n  createObjList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val.unpack());\n      }\n    }\n    return ret;\n  }\n}","map":{"version":3,"names":["FILE_IDENTIFIER_LENGTH","SIZEOF_INT","Encoding","float32","float64","int32","isLittleEndian","ByteBuffer","constructor","bytes_","position_","text_decoder_","TextDecoder","allocate","byte_size","Uint8Array","clear","bytes","position","setPosition","capacity","length","readInt8","offset","readUint8","readInt16","readUint16","readInt32","readUint32","readInt64","BigInt","asIntN","readUint64","asUintN","readFloat32","readFloat64","writeInt8","value","writeUint8","writeInt16","writeUint16","writeInt32","writeUint32","writeInt64","Number","writeUint64","writeFloat32","writeFloat64","getBufferIdentifier","Error","result","i","String","fromCharCode","__offset","bb_pos","vtable_offset","vtable","__union","t","bb","__string","opt_encoding","utf8bytes","subarray","UTF8_BYTES","decode","__union_with_string","o","__indirect","__vector","__vector_len","__has_identifier","ident","charCodeAt","createScalarList","listAccessor","listLength","ret","val","push","createObjList","unpack"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/flatbuffers/mjs/byte-buffer.js"],"sourcesContent":["import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from './constants.js';\nimport { Encoding } from './encoding.js';\nimport { float32, float64, int32, isLittleEndian } from './utils.js';\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return (this.readUint8(offset) << 24) >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return (this.readUint16(offset) << 16) >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | (this.bytes_[offset + 1] << 8);\n    }\n    readInt32(offset) {\n        return (this.bytes_[offset] |\n            (this.bytes_[offset + 1] << 8) |\n            (this.bytes_[offset + 2] << 16) |\n            (this.bytes_[offset + 3] << 24));\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) +\n            (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) +\n            (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length <\n            this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = '';\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable)\n            ? this.readInt16(vtable + vtable_offset)\n            : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,EAAEC,UAAU,QAAQ,gBAAgB;AACnE,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAEC,cAAc,QAAQ,YAAY;AACpE,OAAO,MAAMC,UAAU,CAAC;EACpB;AACJ;AACA;EACIC,WAAWA,CAACC,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,aAAa,GAAG,IAAIC,WAAW,CAAC,CAAC;EAC1C;EACA;AACJ;AACA;EACI,OAAOC,QAAQA,CAACC,SAAS,EAAE;IACvB,OAAO,IAAIP,UAAU,CAAC,IAAIQ,UAAU,CAACD,SAAS,CAAC,CAAC;EACpD;EACAE,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACN,SAAS,GAAG,CAAC;EACtB;EACA;AACJ;AACA;EACIO,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAI,CAACR,MAAM;EACtB;EACA;AACJ;AACA;EACIS,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACR,SAAS;EACzB;EACA;AACJ;AACA;EACIS,WAAWA,CAACD,QAAQ,EAAE;IAClB,IAAI,CAACR,SAAS,GAAGQ,QAAQ;EAC7B;EACA;AACJ;AACA;EACIE,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACX,MAAM,CAACY,MAAM;EAC7B;EACAC,QAAQA,CAACC,MAAM,EAAE;IACb,OAAQ,IAAI,CAACC,SAAS,CAACD,MAAM,CAAC,IAAI,EAAE,IAAK,EAAE;EAC/C;EACAC,SAASA,CAACD,MAAM,EAAE;IACd,OAAO,IAAI,CAACd,MAAM,CAACc,MAAM,CAAC;EAC9B;EACAE,SAASA,CAACF,MAAM,EAAE;IACd,OAAQ,IAAI,CAACG,UAAU,CAACH,MAAM,CAAC,IAAI,EAAE,IAAK,EAAE;EAChD;EACAG,UAAUA,CAACH,MAAM,EAAE;IACf,OAAO,IAAI,CAACd,MAAM,CAACc,MAAM,CAAC,GAAI,IAAI,CAACd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE;EAC/D;EACAI,SAASA,CAACJ,MAAM,EAAE;IACd,OAAQ,IAAI,CAACd,MAAM,CAACc,MAAM,CAAC,GACtB,IAAI,CAACd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAE,GAC7B,IAAI,CAACd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG,GAC9B,IAAI,CAACd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,EAAG;EACvC;EACAK,UAAUA,CAACL,MAAM,EAAE;IACf,OAAO,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC,KAAK,CAAC;EACvC;EACAM,SAASA,CAACN,MAAM,EAAE;IACd,OAAOO,MAAM,CAACC,MAAM,CAAC,EAAE,EAAED,MAAM,CAAC,IAAI,CAACF,UAAU,CAACL,MAAM,CAAC,CAAC,IACnDO,MAAM,CAAC,IAAI,CAACF,UAAU,CAACL,MAAM,GAAG,CAAC,CAAC,CAAC,IAAIO,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EAC5D;EACAE,UAAUA,CAACT,MAAM,EAAE;IACf,OAAOO,MAAM,CAACG,OAAO,CAAC,EAAE,EAAEH,MAAM,CAAC,IAAI,CAACF,UAAU,CAACL,MAAM,CAAC,CAAC,IACpDO,MAAM,CAAC,IAAI,CAACF,UAAU,CAACL,MAAM,GAAG,CAAC,CAAC,CAAC,IAAIO,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EAC5D;EACAI,WAAWA,CAACX,MAAM,EAAE;IAChBlB,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACsB,SAAS,CAACJ,MAAM,CAAC;IACjC,OAAOpB,OAAO,CAAC,CAAC,CAAC;EACrB;EACAgC,WAAWA,CAACZ,MAAM,EAAE;IAChBlB,KAAK,CAACC,cAAc,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACqB,SAAS,CAACJ,MAAM,CAAC;IACtDlB,KAAK,CAACC,cAAc,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACqB,SAAS,CAACJ,MAAM,GAAG,CAAC,CAAC;IAC1D,OAAOnB,OAAO,CAAC,CAAC,CAAC;EACrB;EACAgC,SAASA,CAACb,MAAM,EAAEc,KAAK,EAAE;IACrB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;EAC/B;EACAC,UAAUA,CAACf,MAAM,EAAEc,KAAK,EAAE;IACtB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;EAC/B;EACAE,UAAUA,CAAChB,MAAM,EAAEc,KAAK,EAAE;IACtB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;IAC3B,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,CAAC;EACxC;EACAG,WAAWA,CAACjB,MAAM,EAAEc,KAAK,EAAE;IACvB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;IAC3B,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,CAAC;EACxC;EACAI,UAAUA,CAAClB,MAAM,EAAEc,KAAK,EAAE;IACtB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;IAC3B,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,CAAC;IACpC,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,EAAE;IACrC,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,EAAE;EACzC;EACAK,WAAWA,CAACnB,MAAM,EAAEc,KAAK,EAAE;IACvB,IAAI,CAAC5B,MAAM,CAACc,MAAM,CAAC,GAAGc,KAAK;IAC3B,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,CAAC;IACpC,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,EAAE;IACrC,IAAI,CAAC5B,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAGc,KAAK,IAAI,EAAE;EACzC;EACAM,UAAUA,CAACpB,MAAM,EAAEc,KAAK,EAAE;IACtB,IAAI,CAACI,UAAU,CAAClB,MAAM,EAAEqB,MAAM,CAACd,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEM,KAAK,CAAC,CAAC,CAAC;IACzD,IAAI,CAACI,UAAU,CAAClB,MAAM,GAAG,CAAC,EAAEqB,MAAM,CAACd,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEM,KAAK,IAAIP,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/E;EACAe,WAAWA,CAACtB,MAAM,EAAEc,KAAK,EAAE;IACvB,IAAI,CAACK,WAAW,CAACnB,MAAM,EAAEqB,MAAM,CAACd,MAAM,CAACG,OAAO,CAAC,EAAE,EAAEI,KAAK,CAAC,CAAC,CAAC;IAC3D,IAAI,CAACK,WAAW,CAACnB,MAAM,GAAG,CAAC,EAAEqB,MAAM,CAACd,MAAM,CAACG,OAAO,CAAC,EAAE,EAAEI,KAAK,IAAIP,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACjF;EACAgB,YAAYA,CAACvB,MAAM,EAAEc,KAAK,EAAE;IACxBlC,OAAO,CAAC,CAAC,CAAC,GAAGkC,KAAK;IAClB,IAAI,CAACI,UAAU,CAAClB,MAAM,EAAElB,KAAK,CAAC,CAAC,CAAC,CAAC;EACrC;EACA0C,YAAYA,CAACxB,MAAM,EAAEc,KAAK,EAAE;IACxBjC,OAAO,CAAC,CAAC,CAAC,GAAGiC,KAAK;IAClB,IAAI,CAACI,UAAU,CAAClB,MAAM,EAAElB,KAAK,CAACC,cAAc,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IACtD,IAAI,CAACmC,UAAU,CAAClB,MAAM,GAAG,CAAC,EAAElB,KAAK,CAACC,cAAc,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC9D;EACA;AACJ;AACA;AACA;AACA;EACI0C,mBAAmBA,CAAA,EAAG;IAClB,IAAI,IAAI,CAACvC,MAAM,CAACY,MAAM,GAClB,IAAI,CAACX,SAAS,GAAGT,UAAU,GAAGD,sBAAsB,EAAE;MACtD,MAAM,IAAIiD,KAAK,CAAC,gEAAgE,CAAC;IACrF;IACA,IAAIC,MAAM,GAAG,EAAE;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnD,sBAAsB,EAAEmD,CAAC,EAAE,EAAE;MAC7CD,MAAM,IAAIE,MAAM,CAACC,YAAY,CAAC,IAAI,CAAC/B,QAAQ,CAAC,IAAI,CAACZ,SAAS,GAAGT,UAAU,GAAGkD,CAAC,CAAC,CAAC;IACjF;IACA,OAAOD,MAAM;EACjB;EACA;AACJ;AACA;AACA;EACII,QAAQA,CAACC,MAAM,EAAEC,aAAa,EAAE;IAC5B,MAAMC,MAAM,GAAGF,MAAM,GAAG,IAAI,CAAC5B,SAAS,CAAC4B,MAAM,CAAC;IAC9C,OAAOC,aAAa,GAAG,IAAI,CAAC/B,SAAS,CAACgC,MAAM,CAAC,GACvC,IAAI,CAAChC,SAAS,CAACgC,MAAM,GAAGD,aAAa,CAAC,GACtC,CAAC;EACX;EACA;AACJ;AACA;EACIE,OAAOA,CAACC,CAAC,EAAEpC,MAAM,EAAE;IACfoC,CAAC,CAACJ,MAAM,GAAGhC,MAAM,GAAG,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC;IAC1CoC,CAAC,CAACC,EAAE,GAAG,IAAI;IACX,OAAOD,CAAC;EACZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,QAAQA,CAACtC,MAAM,EAAEuC,YAAY,EAAE;IAC3BvC,MAAM,IAAI,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC;IAChC,MAAMF,MAAM,GAAG,IAAI,CAACM,SAAS,CAACJ,MAAM,CAAC;IACrCA,MAAM,IAAItB,UAAU;IACpB,MAAM8D,SAAS,GAAG,IAAI,CAACtD,MAAM,CAACuD,QAAQ,CAACzC,MAAM,EAAEA,MAAM,GAAGF,MAAM,CAAC;IAC/D,IAAIyC,YAAY,KAAK5D,QAAQ,CAAC+D,UAAU,EACpC,OAAOF,SAAS,CAAC,KAEjB,OAAO,IAAI,CAACpD,aAAa,CAACuD,MAAM,CAACH,SAAS,CAAC;EACnD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACII,mBAAmBA,CAACC,CAAC,EAAE7C,MAAM,EAAE;IAC3B,IAAI,OAAO6C,CAAC,KAAK,QAAQ,EAAE;MACvB,OAAO,IAAI,CAACP,QAAQ,CAACtC,MAAM,CAAC;IAChC;IACA,OAAO,IAAI,CAACmC,OAAO,CAACU,CAAC,EAAE7C,MAAM,CAAC;EAClC;EACA;AACJ;AACA;EACI8C,UAAUA,CAAC9C,MAAM,EAAE;IACf,OAAOA,MAAM,GAAG,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC;EAC1C;EACA;AACJ;AACA;EACI+C,QAAQA,CAAC/C,MAAM,EAAE;IACb,OAAOA,MAAM,GAAG,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC,GAAGtB,UAAU,CAAC,CAAC;EACzD;EACA;AACJ;AACA;EACIsE,YAAYA,CAAChD,MAAM,EAAE;IACjB,OAAO,IAAI,CAACI,SAAS,CAACJ,MAAM,GAAG,IAAI,CAACI,SAAS,CAACJ,MAAM,CAAC,CAAC;EAC1D;EACAiD,gBAAgBA,CAACC,KAAK,EAAE;IACpB,IAAIA,KAAK,CAACpD,MAAM,IAAIrB,sBAAsB,EAAE;MACxC,MAAM,IAAIiD,KAAK,CAAC,8CAA8C,GAAGjD,sBAAsB,CAAC;IAC5F;IACA,KAAK,IAAImD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnD,sBAAsB,EAAEmD,CAAC,EAAE,EAAE;MAC7C,IAAIsB,KAAK,CAACC,UAAU,CAACvB,CAAC,CAAC,IAAI,IAAI,CAAC7B,QAAQ,CAAC,IAAI,CAACJ,QAAQ,CAAC,CAAC,GAAGjB,UAAU,GAAGkD,CAAC,CAAC,EAAE;QACxE,OAAO,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIwB,gBAAgBA,CAACC,YAAY,EAAEC,UAAU,EAAE;IACvC,MAAMC,GAAG,GAAG,EAAE;IACd,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,UAAU,EAAE,EAAE1B,CAAC,EAAE;MACjC,MAAM4B,GAAG,GAAGH,YAAY,CAACzB,CAAC,CAAC;MAC3B,IAAI4B,GAAG,KAAK,IAAI,EAAE;QACdD,GAAG,CAACE,IAAI,CAACD,GAAG,CAAC;MACjB;IACJ;IACA,OAAOD,GAAG;EACd;EACA;AACJ;AACA;AACA;AACA;AACA;EACIG,aAAaA,CAACL,YAAY,EAAEC,UAAU,EAAE;IACpC,MAAMC,GAAG,GAAG,EAAE;IACd,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,UAAU,EAAE,EAAE1B,CAAC,EAAE;MACjC,MAAM4B,GAAG,GAAGH,YAAY,CAACzB,CAAC,CAAC;MAC3B,IAAI4B,GAAG,KAAK,IAAI,EAAE;QACdD,GAAG,CAACE,IAAI,CAACD,GAAG,CAACG,MAAM,CAAC,CAAC,CAAC;MAC1B;IACJ;IACA,OAAOJ,GAAG;EACd;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}