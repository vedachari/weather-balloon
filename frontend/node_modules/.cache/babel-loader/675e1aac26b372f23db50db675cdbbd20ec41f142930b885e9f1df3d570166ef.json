{"ast":null,"code":"import { ByteBuffer } from './byte-buffer.js';\nimport { FILE_IDENTIFIER_LENGTH, SIZE_PREFIX_LENGTH, SIZEOF_INT, SIZEOF_SHORT } from './constants.js';\nexport class Builder {\n  /**\n   * Create a FlatBufferBuilder.\n   */\n  constructor(opt_initial_size) {\n    /** Minimum alignment encountered so far. */\n    this.minalign = 1;\n    /** The vtable for the current table. */\n    this.vtable = null;\n    /** The amount of fields we're actually using. */\n    this.vtable_in_use = 0;\n    /** Whether we are currently serializing a table. */\n    this.isNested = false;\n    /** Starting offset of the current struct/table. */\n    this.object_start = 0;\n    /** List of offsets of all vtables. */\n    this.vtables = [];\n    /** For the current vector being built. */\n    this.vector_num_elems = 0;\n    /** False omits default values from the serialized data */\n    this.force_defaults = false;\n    this.string_maps = null;\n    this.text_encoder = new TextEncoder();\n    let initial_size;\n    if (!opt_initial_size) {\n      initial_size = 1024;\n    } else {\n      initial_size = opt_initial_size;\n    }\n    /**\n     * @type {ByteBuffer}\n     * @private\n     */\n    this.bb = ByteBuffer.allocate(initial_size);\n    this.space = initial_size;\n  }\n  clear() {\n    this.bb.clear();\n    this.space = this.bb.capacity();\n    this.minalign = 1;\n    this.vtable = null;\n    this.vtable_in_use = 0;\n    this.isNested = false;\n    this.object_start = 0;\n    this.vtables = [];\n    this.vector_num_elems = 0;\n    this.force_defaults = false;\n    this.string_maps = null;\n  }\n  /**\n   * In order to save space, fields that are set to their default value\n   * don't get serialized into the buffer. Forcing defaults provides a\n   * way to manually disable this optimization.\n   *\n   * @param forceDefaults true always serializes default values\n   */\n  forceDefaults(forceDefaults) {\n    this.force_defaults = forceDefaults;\n  }\n  /**\n   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n   * called finish(). The actual data starts at the ByteBuffer's current position,\n   * not necessarily at 0.\n   */\n  dataBuffer() {\n    return this.bb;\n  }\n  /**\n   * Get the bytes representing the FlatBuffer. Only call this after you've\n   * called finish().\n   */\n  asUint8Array() {\n    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n  }\n  /**\n   * Prepare to write an element of `size` after `additional_bytes` have been\n   * written, e.g. if you write a string, you need to align such the int length\n   * field is aligned to 4 bytes, and the string data follows it directly. If all\n   * you need to do is alignment, `additional_bytes` will be 0.\n   *\n   * @param size This is the of the new element to write\n   * @param additional_bytes The padding size\n   */\n  prep(size, additional_bytes) {\n    // Track the biggest thing we've ever aligned to.\n    if (size > this.minalign) {\n      this.minalign = size;\n    }\n    // Find the amount of alignment needed such that `size` is properly\n    // aligned after `additional_bytes`\n    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n    // Reallocate the buffer if needed.\n    while (this.space < align_size + size + additional_bytes) {\n      const old_buf_size = this.bb.capacity();\n      this.bb = Builder.growByteBuffer(this.bb);\n      this.space += this.bb.capacity() - old_buf_size;\n    }\n    this.pad(align_size);\n  }\n  pad(byte_size) {\n    for (let i = 0; i < byte_size; i++) {\n      this.bb.writeInt8(--this.space, 0);\n    }\n  }\n  writeInt8(value) {\n    this.bb.writeInt8(this.space -= 1, value);\n  }\n  writeInt16(value) {\n    this.bb.writeInt16(this.space -= 2, value);\n  }\n  writeInt32(value) {\n    this.bb.writeInt32(this.space -= 4, value);\n  }\n  writeInt64(value) {\n    this.bb.writeInt64(this.space -= 8, value);\n  }\n  writeFloat32(value) {\n    this.bb.writeFloat32(this.space -= 4, value);\n  }\n  writeFloat64(value) {\n    this.bb.writeFloat64(this.space -= 8, value);\n  }\n  /**\n   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int8` to add the buffer.\n   */\n  addInt8(value) {\n    this.prep(1, 0);\n    this.writeInt8(value);\n  }\n  /**\n   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int16` to add the buffer.\n   */\n  addInt16(value) {\n    this.prep(2, 0);\n    this.writeInt16(value);\n  }\n  /**\n   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int32` to add the buffer.\n   */\n  addInt32(value) {\n    this.prep(4, 0);\n    this.writeInt32(value);\n  }\n  /**\n   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `int64` to add the buffer.\n   */\n  addInt64(value) {\n    this.prep(8, 0);\n    this.writeInt64(value);\n  }\n  /**\n   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float32` to add the buffer.\n   */\n  addFloat32(value) {\n    this.prep(4, 0);\n    this.writeFloat32(value);\n  }\n  /**\n   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n   * @param value The `float64` to add the buffer.\n   */\n  addFloat64(value) {\n    this.prep(8, 0);\n    this.writeFloat64(value);\n  }\n  addFieldInt8(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt8(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt16(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt16(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addInt32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldInt64(voffset, value, defaultValue) {\n    if (this.force_defaults || value !== defaultValue) {\n      this.addInt64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat32(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat32(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldFloat64(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addFloat64(value);\n      this.slot(voffset);\n    }\n  }\n  addFieldOffset(voffset, value, defaultValue) {\n    if (this.force_defaults || value != defaultValue) {\n      this.addOffset(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n   */\n  addFieldStruct(voffset, value, defaultValue) {\n    if (value != defaultValue) {\n      this.nested(value);\n      this.slot(voffset);\n    }\n  }\n  /**\n   * Structures are always stored inline, they need to be created right\n   * where they're used.  You'll get this assertion failure if you\n   * created it elsewhere.\n   */\n  nested(obj) {\n    if (obj != this.offset()) {\n      throw new TypeError('FlatBuffers: struct must be serialized inline.');\n    }\n  }\n  /**\n   * Should not be creating any other object, string or vector\n   * while an object is being constructed\n   */\n  notNested() {\n    if (this.isNested) {\n      throw new TypeError('FlatBuffers: object serialization must not be nested.');\n    }\n  }\n  /**\n   * Set the current vtable at `voffset` to the current location in the buffer.\n   */\n  slot(voffset) {\n    if (this.vtable !== null) this.vtable[voffset] = this.offset();\n  }\n  /**\n   * @returns Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.bb.capacity() - this.space;\n  }\n  /**\n   * Doubles the size of the backing ByteBuffer and copies the old data towards\n   * the end of the new buffer (since we build the buffer backwards).\n   *\n   * @param bb The current buffer with the existing data\n   * @returns A new byte buffer with the old data copied\n   * to it. The data is located at the end of the buffer.\n   *\n   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n   * it a uint8Array we need to suppress the type check:\n   * @suppress {checkTypes}\n   */\n  static growByteBuffer(bb) {\n    const old_buf_size = bb.capacity();\n    // Ensure we don't grow beyond what fits in an int.\n    if (old_buf_size & 0xc0000000) {\n      throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n    }\n    const new_buf_size = old_buf_size << 1;\n    const nbb = ByteBuffer.allocate(new_buf_size);\n    nbb.setPosition(new_buf_size - old_buf_size);\n    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n    return nbb;\n  }\n  /**\n   * Adds on offset, relative to where it will be written.\n   *\n   * @param offset The offset to add.\n   */\n  addOffset(offset) {\n    this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n    this.writeInt32(this.offset() - offset + SIZEOF_INT);\n  }\n  /**\n   * Start encoding a new object in the buffer.  Users will not usually need to\n   * call this directly. The FlatBuffers compiler will generate helper methods\n   * that call this method internally.\n   */\n  startObject(numfields) {\n    this.notNested();\n    if (this.vtable == null) {\n      this.vtable = [];\n    }\n    this.vtable_in_use = numfields;\n    for (let i = 0; i < numfields; i++) {\n      this.vtable[i] = 0; // This will push additional elements as needed\n    }\n    this.isNested = true;\n    this.object_start = this.offset();\n  }\n  /**\n   * Finish off writing the object that is under construction.\n   *\n   * @returns The offset to the object inside `dataBuffer`\n   */\n  endObject() {\n    if (this.vtable == null || !this.isNested) {\n      throw new Error('FlatBuffers: endObject called without startObject');\n    }\n    this.addInt32(0);\n    const vtableloc = this.offset();\n    // Trim trailing zeroes.\n    let i = this.vtable_in_use - 1;\n    // eslint-disable-next-line no-empty\n    for (; i >= 0 && this.vtable[i] == 0; i--) {}\n    const trimmed_size = i + 1;\n    // Write out the current vtable.\n    for (; i >= 0; i--) {\n      // Offset relative to the start of the table.\n      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n    }\n    const standard_fields = 2; // The fields below:\n    this.addInt16(vtableloc - this.object_start);\n    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n    this.addInt16(len);\n    // Search for an existing vtable that matches the current one.\n    let existing_vtable = 0;\n    const vt1 = this.space;\n    outer_loop: for (i = 0; i < this.vtables.length; i++) {\n      const vt2 = this.bb.capacity() - this.vtables[i];\n      if (len == this.bb.readInt16(vt2)) {\n        for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n          if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n            continue outer_loop;\n          }\n        }\n        existing_vtable = this.vtables[i];\n        break;\n      }\n    }\n    if (existing_vtable) {\n      // Found a match:\n      // Remove the current vtable.\n      this.space = this.bb.capacity() - vtableloc;\n      // Point table to existing vtable.\n      this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n    } else {\n      // No match:\n      // Add the location of the current vtable to the list of vtables.\n      this.vtables.push(this.offset());\n      // Point table to current vtable.\n      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n    }\n    this.isNested = false;\n    return vtableloc;\n  }\n  /**\n   * Finalize a buffer, poiting to the given `root_table`.\n   */\n  finish(root_table, opt_file_identifier, opt_size_prefix) {\n    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n    if (opt_file_identifier) {\n      const file_identifier = opt_file_identifier;\n      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n        throw new TypeError('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n      }\n      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n        this.writeInt8(file_identifier.charCodeAt(i));\n      }\n    }\n    this.prep(this.minalign, SIZEOF_INT + size_prefix);\n    this.addOffset(root_table);\n    if (size_prefix) {\n      this.addInt32(this.bb.capacity() - this.space);\n    }\n    this.bb.setPosition(this.space);\n  }\n  /**\n   * Finalize a size prefixed buffer, pointing to the given `root_table`.\n   */\n  finishSizePrefixed(root_table, opt_file_identifier) {\n    this.finish(root_table, opt_file_identifier, true);\n  }\n  /**\n   * This checks a required field has been set in a given table that has\n   * just been constructed.\n   */\n  requiredField(table, field) {\n    const table_start = this.bb.capacity() - table;\n    const vtable_start = table_start - this.bb.readInt32(table_start);\n    const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;\n    // If this fails, the caller will show what field needs to be set.\n    if (!ok) {\n      throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n    }\n  }\n  /**\n   * Start a new array/vector of objects.  Users usually will not call\n   * this directly. The FlatBuffers compiler will create a start/end\n   * method for vector types in generated code.\n   *\n   * @param elem_size The size of each element in the array\n   * @param num_elems The number of elements in the array\n   * @param alignment The alignment of the array\n   */\n  startVector(elem_size, num_elems, alignment) {\n    this.notNested();\n    this.vector_num_elems = num_elems;\n    this.prep(SIZEOF_INT, elem_size * num_elems);\n    this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n  }\n  /**\n   * Finish off the creation of an array and all its elements. The array must be\n   * created with `startVector`.\n   *\n   * @returns The offset at which the newly created array\n   * starts.\n   */\n  endVector() {\n    this.writeInt32(this.vector_num_elems);\n    return this.offset();\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If the string passed has\n   * already been seen, we return the offset of the already written string\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createSharedString(s) {\n    if (!s) {\n      return 0;\n    }\n    if (!this.string_maps) {\n      this.string_maps = new Map();\n    }\n    if (this.string_maps.has(s)) {\n      return this.string_maps.get(s);\n    }\n    const offset = this.createString(s);\n    this.string_maps.set(s, offset);\n    return offset;\n  }\n  /**\n   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n   * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n   *\n   * @param s The string to encode\n   * @return The offset in the buffer where the encoded string starts\n   */\n  createString(s) {\n    if (s === null || s === undefined) {\n      return 0;\n    }\n    let utf8;\n    if (s instanceof Uint8Array) {\n      utf8 = s;\n    } else {\n      utf8 = this.text_encoder.encode(s);\n    }\n    this.addInt8(0);\n    this.startVector(1, utf8.length, 1);\n    this.bb.setPosition(this.space -= utf8.length);\n    this.bb.bytes().set(utf8, this.space);\n    return this.endVector();\n  }\n  /**\n   * Create a byte vector.\n   *\n   * @param v The bytes to add\n   * @returns The offset in the buffer where the byte vector starts\n   */\n  createByteVector(v) {\n    if (v === null || v === undefined) {\n      return 0;\n    }\n    this.startVector(1, v.length, 1);\n    this.bb.setPosition(this.space -= v.length);\n    this.bb.bytes().set(v, this.space);\n    return this.endVector();\n  }\n  /**\n   * A helper function to pack an object\n   *\n   * @returns offset of obj\n   */\n  createObjectOffset(obj) {\n    if (obj === null) {\n      return 0;\n    }\n    if (typeof obj === 'string') {\n      return this.createString(obj);\n    } else {\n      return obj.pack(this);\n    }\n  }\n  /**\n   * A helper function to pack a list of object\n   *\n   * @returns list of offsets of each non null object\n   */\n  createObjectOffsetList(list) {\n    const ret = [];\n    for (let i = 0; i < list.length; ++i) {\n      const val = list[i];\n      if (val !== null) {\n        ret.push(this.createObjectOffset(val));\n      } else {\n        throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n      }\n    }\n    return ret;\n  }\n  createStructOffsetList(list, startFunc) {\n    startFunc(this, list.length);\n    this.createObjectOffsetList(list.slice().reverse());\n    return this.endVector();\n  }\n}","map":{"version":3,"names":["ByteBuffer","FILE_IDENTIFIER_LENGTH","SIZE_PREFIX_LENGTH","SIZEOF_INT","SIZEOF_SHORT","Builder","constructor","opt_initial_size","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","string_maps","text_encoder","TextEncoder","initial_size","bb","allocate","space","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","size","additional_bytes","align_size","old_buf_size","growByteBuffer","pad","byte_size","i","writeInt8","value","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","voffset","defaultValue","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","obj","TypeError","notNested","Error","new_buf_size","nbb","setPosition","set","startObject","numfields","endObject","vtableloc","trimmed_size","standard_fields","len","existing_vtable","vt1","outer_loop","length","vt2","readInt16","j","push","finish","root_table","opt_file_identifier","opt_size_prefix","size_prefix","file_identifier","charCodeAt","finishSizePrefixed","requiredField","table","field","table_start","vtable_start","readInt32","ok","startVector","elem_size","num_elems","alignment","endVector","createSharedString","s","Map","has","get","createString","undefined","utf8","Uint8Array","encode","createByteVector","v","createObjectOffset","pack","createObjectOffsetList","list","ret","val","createStructOffsetList","startFunc","slice","reverse"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/flatbuffers/mjs/builder.js"],"sourcesContent":["import { ByteBuffer } from './byte-buffer.js';\nimport { FILE_IDENTIFIER_LENGTH, SIZE_PREFIX_LENGTH, SIZEOF_INT, SIZEOF_SHORT, } from './constants.js';\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb\n            .bytes()\n            .subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = (~(this.bb.capacity() - this.space + additional_bytes) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8((this.space -= 1), value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16((this.space -= 2), value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32((this.space -= 4), value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64((this.space -= 8), value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32((this.space -= 4), value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64((this.space -= 8), value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new TypeError('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new TypeError('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xc0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new TypeError('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new TypeError('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition((this.space -= utf8.length));\n        this.bb.bytes().set(utf8, this.space);\n        return this.endVector();\n    }\n    /**\n     * Create a byte vector.\n     *\n     * @param v The bytes to add\n     * @returns The offset in the buffer where the byte vector starts\n     */\n    createByteVector(v) {\n        if (v === null || v === undefined) {\n            return 0;\n        }\n        this.startVector(1, v.length, 1);\n        this.bb.setPosition((this.space -= v.length));\n        this.bb.bytes().set(v, this.space);\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}