{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useAnimateInternal } from \"../../internals/animation/useAnimateInternal.js\";\n/**\n * Hook to customize the animation of an element.\n * Animates a ref from `initialProps` to `props`.\n *\n * @param {object} props The props to animate to.\n *\n * @returns an object containing a ref that should be passed to the element to animate and the transformed props.\n * If `skip` is true, the transformed props are the `props` to animate to; if it is false, the transformed props are the\n * `initialProps`.\n *\n * The animated props are only accessible in `applyProps`. The props returned from this hook are not animated.\n *\n * When an animation starts, an interpolator is created using `createInterpolator`.\n * On every animation frame:\n * 1. The interpolator is called to get the interpolated props;\n * 2. `transformProps` is called to transform the interpolated props;\n * 3. `applyProps` is called to apply the transformed props to the element.\n *\n * If `props` change while an animation is progress, the animation will continue towards the new `props`.\n *\n * The animation can be skipped by setting `skip` to true. If a transition is in progress, it will immediately end\n * and `applyProps` be called with the final value. If there isn't a transition in progress, a new one won't be\n * started and `applyProps` will not be called.\n * */\nexport function useAnimate(props, {\n  createInterpolator,\n  transformProps,\n  applyProps,\n  skip,\n  initialProps = props,\n  ref\n}) {\n  const transform = transformProps ?? (p => p);\n  const [animateRef, lastInterpolatedProps] = useAnimateInternal(props, {\n    initialProps,\n    createInterpolator,\n    applyProps: (element, animatedProps) => applyProps(element, transform(animatedProps)),\n    skip\n  });\n  const usedProps = skip ? transformProps(props) : transformProps(lastInterpolatedProps);\n  return _extends({}, usedProps, {\n    ref: useForkRef(animateRef, ref)\n  });\n}","map":{"version":3,"names":["_extends","useForkRef","useAnimateInternal","useAnimate","props","createInterpolator","transformProps","applyProps","skip","initialProps","ref","transform","p","animateRef","lastInterpolatedProps","element","animatedProps","usedProps"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-charts/esm/hooks/animation/useAnimate.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useAnimateInternal } from \"../../internals/animation/useAnimateInternal.js\";\n/**\n * Hook to customize the animation of an element.\n * Animates a ref from `initialProps` to `props`.\n *\n * @param {object} props The props to animate to.\n *\n * @returns an object containing a ref that should be passed to the element to animate and the transformed props.\n * If `skip` is true, the transformed props are the `props` to animate to; if it is false, the transformed props are the\n * `initialProps`.\n *\n * The animated props are only accessible in `applyProps`. The props returned from this hook are not animated.\n *\n * When an animation starts, an interpolator is created using `createInterpolator`.\n * On every animation frame:\n * 1. The interpolator is called to get the interpolated props;\n * 2. `transformProps` is called to transform the interpolated props;\n * 3. `applyProps` is called to apply the transformed props to the element.\n *\n * If `props` change while an animation is progress, the animation will continue towards the new `props`.\n *\n * The animation can be skipped by setting `skip` to true. If a transition is in progress, it will immediately end\n * and `applyProps` be called with the final value. If there isn't a transition in progress, a new one won't be\n * started and `applyProps` will not be called.\n * */\nexport function useAnimate(props, {\n  createInterpolator,\n  transformProps,\n  applyProps,\n  skip,\n  initialProps = props,\n  ref\n}) {\n  const transform = transformProps ?? (p => p);\n  const [animateRef, lastInterpolatedProps] = useAnimateInternal(props, {\n    initialProps,\n    createInterpolator,\n    applyProps: (element, animatedProps) => applyProps(element, transform(animatedProps)),\n    skip\n  });\n  const usedProps = skip ? transformProps(props) : transformProps(lastInterpolatedProps);\n  return _extends({}, usedProps, {\n    ref: useForkRef(animateRef, ref)\n  });\n}"],"mappings":"AAAA,YAAY;;AAEZ,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,SAASC,kBAAkB,QAAQ,iDAAiD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,KAAK,EAAE;EAChCC,kBAAkB;EAClBC,cAAc;EACdC,UAAU;EACVC,IAAI;EACJC,YAAY,GAAGL,KAAK;EACpBM;AACF,CAAC,EAAE;EACD,MAAMC,SAAS,GAAGL,cAAc,KAAKM,CAAC,IAAIA,CAAC,CAAC;EAC5C,MAAM,CAACC,UAAU,EAAEC,qBAAqB,CAAC,GAAGZ,kBAAkB,CAACE,KAAK,EAAE;IACpEK,YAAY;IACZJ,kBAAkB;IAClBE,UAAU,EAAEA,CAACQ,OAAO,EAAEC,aAAa,KAAKT,UAAU,CAACQ,OAAO,EAAEJ,SAAS,CAACK,aAAa,CAAC,CAAC;IACrFR;EACF,CAAC,CAAC;EACF,MAAMS,SAAS,GAAGT,IAAI,GAAGF,cAAc,CAACF,KAAK,CAAC,GAAGE,cAAc,CAACQ,qBAAqB,CAAC;EACtF,OAAOd,QAAQ,CAAC,CAAC,CAAC,EAAEiB,SAAS,EAAE;IAC7BP,GAAG,EAAET,UAAU,CAACY,UAAU,EAAEH,GAAG;EACjC,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}