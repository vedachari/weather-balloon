{"ast":null,"code":"import { isOrdinalScale } from \"../../../scaleGuards.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n/**\n * For a pointer coordinate, this function returns the dataIndex associated.\n * Returns `-1` if no dataIndex matches.\n */\nexport function getAxisIndex(axisConfig, pointerValue) {\n  const {\n    scale,\n    data: axisData,\n    reverse\n  } = axisConfig;\n  if (!isOrdinalScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (axisData === undefined) {\n      return -1;\n    }\n    const valueAsNumber = getAsANumber(value);\n    const closestIndex = axisData?.findIndex((pointValue, index) => {\n      const v = getAsANumber(pointValue);\n      if (v > valueAsNumber) {\n        if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n          return true;\n        }\n      }\n      if (v <= valueAsNumber) {\n        if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return closestIndex;\n  }\n  const dataIndex = scale.bandwidth() === 0 ? Math.floor((pointerValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((pointerValue - Math.min(...scale.range())) / scale.step());\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return -1;\n  }\n  return reverse ? axisData.length - 1 - dataIndex : dataIndex;\n}\n\n/**\n * For a pointer coordinate, this function returns the value associated.\n * Returns `null` if the coordinate has no value associated.\n */\nexport function getAxisValue(scale, axisData, pointerValue, dataIndex) {\n  if (!isOrdinalScale(scale)) {\n    if (dataIndex === null) {\n      const invertedValue = scale.invert(pointerValue);\n      return Number.isNaN(invertedValue) ? null : invertedValue;\n    }\n    return axisData[dataIndex];\n  }\n  if (dataIndex === null || dataIndex < 0 || dataIndex >= axisData.length) {\n    return null;\n  }\n  return axisData[dataIndex];\n}","map":{"version":3,"names":["isOrdinalScale","getAsANumber","value","Date","getTime","getAxisIndex","axisConfig","pointerValue","scale","data","axisData","reverse","invert","undefined","valueAsNumber","closestIndex","findIndex","pointValue","index","v","Math","abs","length","dataIndex","bandwidth","floor","min","range","step","getAxisValue","invertedValue","Number","isNaN"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/getAxisValue.js"],"sourcesContent":["import { isOrdinalScale } from \"../../../scaleGuards.js\";\nfunction getAsANumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n/**\n * For a pointer coordinate, this function returns the dataIndex associated.\n * Returns `-1` if no dataIndex matches.\n */\nexport function getAxisIndex(axisConfig, pointerValue) {\n  const {\n    scale,\n    data: axisData,\n    reverse\n  } = axisConfig;\n  if (!isOrdinalScale(scale)) {\n    const value = scale.invert(pointerValue);\n    if (axisData === undefined) {\n      return -1;\n    }\n    const valueAsNumber = getAsANumber(value);\n    const closestIndex = axisData?.findIndex((pointValue, index) => {\n      const v = getAsANumber(pointValue);\n      if (v > valueAsNumber) {\n        if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {\n          return true;\n        }\n      }\n      if (v <= valueAsNumber) {\n        if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return closestIndex;\n  }\n  const dataIndex = scale.bandwidth() === 0 ? Math.floor((pointerValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((pointerValue - Math.min(...scale.range())) / scale.step());\n  if (dataIndex < 0 || dataIndex >= axisData.length) {\n    return -1;\n  }\n  return reverse ? axisData.length - 1 - dataIndex : dataIndex;\n}\n\n/**\n * For a pointer coordinate, this function returns the value associated.\n * Returns `null` if the coordinate has no value associated.\n */\nexport function getAxisValue(scale, axisData, pointerValue, dataIndex) {\n  if (!isOrdinalScale(scale)) {\n    if (dataIndex === null) {\n      const invertedValue = scale.invert(pointerValue);\n      return Number.isNaN(invertedValue) ? null : invertedValue;\n    }\n    return axisData[dataIndex];\n  }\n  if (dataIndex === null || dataIndex < 0 || dataIndex >= axisData.length) {\n    return null;\n  }\n  return axisData[dataIndex];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}