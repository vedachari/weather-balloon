{"ast":null,"code":"// @ts-nocheck\n/* eslint-disable */\nimport FlatQueue from 'flatqueue';\nconst ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\nconst VERSION = 3; // serialized format version\n\nexport class Flatbush {\n  /**\n   * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.\n   * @param {ArrayBufferLike} data\n   * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.\n   * @returns {Flatbush} index\n   */\n  static from(data, byteOffset = 0) {\n    if (byteOffset % 8 !== 0) {\n      throw new Error('byteOffset must be 8-byte aligned.');\n    }\n\n    // @ts-expect-error duck typing array buffers\n    if (!data || data.byteLength === undefined || data.buffer) {\n      throw new Error('Data must be an instance of ArrayBuffer or SharedArrayBuffer.');\n    }\n    const [magic, versionAndType] = new Uint8Array(data, byteOffset + 0, 2);\n    if (magic !== 0xfb) {\n      throw new Error('Data does not appear to be in a Flatbush format.');\n    }\n    const version = versionAndType >> 4;\n    if (version !== VERSION) {\n      throw new Error(`Got v${version} data when expected v${VERSION}.`);\n    }\n    const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n    if (!ArrayType) {\n      throw new Error('Unrecognized array type.');\n    }\n    const [nodeSize] = new Uint16Array(data, byteOffset + 2, 1);\n    const [numItems] = new Uint32Array(data, byteOffset + 4, 1);\n    return new Flatbush(numItems, nodeSize, ArrayType, undefined, data, byteOffset);\n  }\n\n  /**\n   * Create a Flatbush index that will hold a given number of items.\n   * @param {number} numItems\n   * @param {number} [nodeSize=16] Size of the tree node (16 by default).\n   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n   * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).\n   * @param {ArrayBufferLike} [data] (Only used internally)\n   * @param {number} [byteOffset=0] (Only used internally)\n   */\n  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data, byteOffset = 0) {\n    if (numItems === undefined) {\n      throw new Error('Missing required argument: numItems.');\n    }\n    if (isNaN(numItems) || numItems <= 0) {\n      throw new Error(`Unexpected numItems value: ${numItems}.`);\n    }\n    this.numItems = +numItems;\n    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    this.byteOffset = byteOffset;\n\n    // calculate the total number of nodes in the R-tree to allocate space for\n    // and the index of each tree level (used in search later)\n    let n = numItems;\n    let numNodes = n;\n    this._levelBounds = [n * 4];\n    do {\n      n = Math.ceil(n / this.nodeSize);\n      numNodes += n;\n      this._levelBounds.push(numNodes * 4);\n    } while (n !== 1);\n    this.ArrayType = ArrayType;\n    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n    const arrayTypeIndex = ARRAY_TYPES.indexOf(ArrayType);\n    const nodesByteSize = numNodes * 4 * ArrayType.BYTES_PER_ELEMENT;\n    if (arrayTypeIndex < 0) {\n      throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n    }\n    if (data) {\n      this.data = data;\n      this._boxes = new ArrayType(data, byteOffset + 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(data, byteOffset + 8 + nodesByteSize, numNodes);\n      this._pos = numNodes * 4;\n      this.minX = this._boxes[this._pos - 4];\n      this.minY = this._boxes[this._pos - 3];\n      this.maxX = this._boxes[this._pos - 2];\n      this.maxY = this._boxes[this._pos - 1];\n    } else {\n      const data = this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n      this._boxes = new ArrayType(data, 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(data, 8 + nodesByteSize, numNodes);\n      this._pos = 0;\n      this.minX = Infinity;\n      this.minY = Infinity;\n      this.maxX = -Infinity;\n      this.maxY = -Infinity;\n      new Uint8Array(data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n      new Uint16Array(data, 2, 1)[0] = nodeSize;\n      new Uint32Array(data, 4, 1)[0] = numItems;\n    }\n\n    // a priority queue for k-nearest-neighbors queries\n    /** @type FlatQueue<number> */\n    this._queue = new FlatQueue();\n  }\n\n  /**\n   * Add a given rectangle to the index.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @returns {number} A zero-based, incremental number that represents the newly added rectangle.\n   */\n  add(minX, minY, maxX = minX, maxY = minY) {\n    const index = this._pos >> 2;\n    const boxes = this._boxes;\n    this._indices[index] = index;\n    boxes[this._pos++] = minX;\n    boxes[this._pos++] = minY;\n    boxes[this._pos++] = maxX;\n    boxes[this._pos++] = maxY;\n    if (minX < this.minX) {\n      this.minX = minX;\n    }\n    if (minY < this.minY) {\n      this.minY = minY;\n    }\n    if (maxX > this.maxX) {\n      this.maxX = maxX;\n    }\n    if (maxY > this.maxY) {\n      this.maxY = maxY;\n    }\n    return index;\n  }\n\n  /** Perform indexing of the added rectangles. */\n  finish() {\n    if (this._pos >> 2 !== this.numItems) {\n      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n    }\n    const boxes = this._boxes;\n    if (this.numItems <= this.nodeSize) {\n      // only one node, skip sorting and just fill the root box\n      boxes[this._pos++] = this.minX;\n      boxes[this._pos++] = this.minY;\n      boxes[this._pos++] = this.maxX;\n      boxes[this._pos++] = this.maxY;\n      return;\n    }\n    const width = this.maxX - this.minX || 1;\n    const height = this.maxY - this.minY || 1;\n    const hilbertValues = new Uint32Array(this.numItems);\n    const hilbertMax = (1 << 16) - 1;\n\n    // map item centers into Hilbert coordinate space and calculate Hilbert values\n    for (let i = 0, pos = 0; i < this.numItems; i++) {\n      const minX = boxes[pos++];\n      const minY = boxes[pos++];\n      const maxX = boxes[pos++];\n      const maxY = boxes[pos++];\n      const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n      const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n      hilbertValues[i] = hilbert(x, y);\n    }\n\n    // sort items by their Hilbert value (for packing later)\n    sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\n\n    // generate nodes at each tree level, bottom-up\n    for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n      const end = this._levelBounds[i];\n\n      // generate a parent node for each block of consecutive <nodeSize> nodes\n      while (pos < end) {\n        const nodeIndex = pos;\n\n        // calculate bbox for the new node\n        let nodeMinX = boxes[pos++];\n        let nodeMinY = boxes[pos++];\n        let nodeMaxX = boxes[pos++];\n        let nodeMaxY = boxes[pos++];\n        for (let j = 1; j < this.nodeSize && pos < end; j++) {\n          nodeMinX = Math.min(nodeMinX, boxes[pos++]);\n          nodeMinY = Math.min(nodeMinY, boxes[pos++]);\n          nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);\n          nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);\n        }\n\n        // add the new node to the tree data\n        this._indices[this._pos >> 2] = nodeIndex;\n        boxes[this._pos++] = nodeMinX;\n        boxes[this._pos++] = nodeMinY;\n        boxes[this._pos++] = nodeMaxX;\n        boxes[this._pos++] = nodeMaxY;\n      }\n    }\n  }\n\n  /**\n   * Search the index by a bounding box.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n   * @returns {number[]} An array containing the index, the x coordinate and the y coordinate of the points intersecting or touching the given bounding box.\n   */\n  search(minX, minY, maxX, maxY, filterFn) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    /** @type number | undefined */\n    let nodeIndex = this._boxes.length - 4;\n    const queue = [];\n    const results = [];\n    while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n      // search through child nodes\n      for (let /** @type number */pos = nodeIndex; pos < end; pos += 4) {\n        // check if node bbox intersects with query bbox\n        if (maxX < this._boxes[pos]) {\n          continue;\n        } // maxX < nodeMinX\n        if (maxY < this._boxes[pos + 1]) {\n          continue;\n        } // maxY < nodeMinY\n        if (minX > this._boxes[pos + 2]) {\n          continue;\n        } // minX > nodeMaxX\n        if (minY > this._boxes[pos + 3]) {\n          continue;\n        } // minY > nodeMaxY\n\n        const index = this._indices[pos >> 2] | 0;\n        if (nodeIndex >= this.numItems * 4) {\n          queue.push(index); // node; add it to the search queue\n        } else if (filterFn === undefined || filterFn(index)) {\n          results.push(index);\n          results.push(this._boxes[pos]); // leaf item\n          results.push(this._boxes[pos + 1]);\n        }\n      }\n      nodeIndex = queue.pop();\n    }\n    return results;\n  }\n\n  /**\n   * Search items in order of distance from the given point.\n   * @param x\n   * @param y\n   * @param [maxResults=Infinity]\n   * @param maxDistSq\n   * @param [filterFn] An optional function for filtering the results.\n   * @param [sqDistFn] An optional function to calculate squared distance from the point to the item.\n   * @returns {number[]} An array of indices of items found.\n   */\n  neighbors(x, y, maxResults = Infinity, maxDistSq = Infinity, filterFn, sqDistFn = sqDist) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    /** @type number | undefined */\n    let nodeIndex = this._boxes.length - 4;\n    const q = this._queue;\n    const results = [];\n\n    /* eslint-disable no-labels */\n    outer: while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n      // add child nodes to the queue\n      for (let pos = nodeIndex; pos < end; pos += 4) {\n        const index = this._indices[pos >> 2] | 0;\n        const minX = this._boxes[pos];\n        const minY = this._boxes[pos + 1];\n        const maxX = this._boxes[pos + 2];\n        const maxY = this._boxes[pos + 3];\n        const dx = x < minX ? minX - x : x > maxX ? x - maxX : 0;\n        const dy = y < minY ? minY - y : y > maxY ? y - maxY : 0;\n        const dist = sqDistFn(dx, dy);\n        if (dist > maxDistSq) {\n          continue;\n        }\n        if (nodeIndex >= this.numItems * 4) {\n          q.push(index << 1, dist); // node (use even id)\n        } else if (filterFn === undefined || filterFn(index)) {\n          q.push((index << 1) + 1, dist); // leaf item (use odd id)\n        }\n      }\n\n      // pop items from the queue\n      // @ts-expect-error q.length check eliminates undefined values\n      while (q.length && q.peek() & 1) {\n        const dist = q.peekValue();\n\n        // @ts-expect-error\n        if (dist > maxDistSq) {\n          break outer;\n        }\n        // @ts-expect-error\n        results.push(q.pop() >> 1);\n        if (results.length === maxResults) {\n          break outer;\n        }\n      }\n\n      // @ts-expect-error\n      nodeIndex = q.length ? q.pop() >> 1 : undefined;\n    }\n    q.clear();\n    return results;\n  }\n}\nfunction sqDist(dx, dy) {\n  return dx * dx + dy * dy;\n}\n\n/**\n * Binary search for the first value in the array bigger than the given.\n * @param {number} value\n * @param {number[]} arr\n */\nfunction upperBound(value, arr) {\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    const m = i + j >> 1;\n    if (arr[m] > value) {\n      j = m;\n    } else {\n      i = m + 1;\n    }\n  }\n  return arr[i];\n}\n\n/**\n * Custom quicksort that partially sorts bbox data alongside the hilbert values.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} left\n * @param {number} right\n * @param {number} nodeSize\n */\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n  if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) {\n    return;\n  }\n\n  // apply median of three method\n  const start = values[left];\n  const mid = values[left + right >> 1];\n  const end = values[right];\n  let pivot = end;\n  const x = Math.max(start, mid);\n  if (end > x) {\n    pivot = x;\n  } else if (x === start) {\n    pivot = Math.max(mid, end);\n  } else if (x === mid) {\n    pivot = Math.max(start, end);\n  }\n  let i = left - 1;\n  let j = right + 1;\n  while (true) {\n    do {\n      i++;\n    } while (values[i] < pivot);\n    do {\n      j--;\n    } while (values[j] > pivot);\n    if (i >= j) {\n      break;\n    }\n    swap(values, boxes, indices, i, j);\n  }\n  sort(values, boxes, indices, left, j, nodeSize);\n  sort(values, boxes, indices, j + 1, right, nodeSize);\n}\n\n/**\n * Swap two values and two corresponding boxes.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} i\n * @param {number} j\n */\nfunction swap(values, boxes, indices, i, j) {\n  const temp = values[i];\n  values[i] = values[j];\n  values[j] = temp;\n  const k = 4 * i;\n  const m = 4 * j;\n  const a = boxes[k];\n  const b = boxes[k + 1];\n  const c = boxes[k + 2];\n  const d = boxes[k + 3];\n  boxes[k] = boxes[m];\n  boxes[k + 1] = boxes[m + 1];\n  boxes[k + 2] = boxes[m + 2];\n  boxes[k + 3] = boxes[m + 3];\n  boxes[m] = a;\n  boxes[m + 1] = b;\n  boxes[m + 2] = c;\n  boxes[m + 3] = d;\n  const e = indices[i];\n  indices[i] = indices[j];\n  indices[j] = e;\n}\n\n/**\n * Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n * Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n * @param {number} x\n * @param {number} y\n */\nfunction hilbert(x, y) {\n  let a = x ^ y;\n  let b = 0xffff ^ a;\n  let c = 0xffff ^ (x | y);\n  let d = x & (y ^ 0xffff);\n  let A = a | b >> 1;\n  let B = a >> 1 ^ a;\n  let C = c >> 1 ^ b & d >> 1 ^ c;\n  let D = a & c >> 1 ^ d >> 1 ^ d;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 2 ^ b & b >> 2;\n  B = a & b >> 2 ^ b & (a ^ b) >> 2;\n  C ^= a & c >> 2 ^ b & d >> 2;\n  D ^= b & c >> 2 ^ (a ^ b) & d >> 2;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 4 ^ b & b >> 4;\n  B = a & b >> 4 ^ b & (a ^ b) >> 4;\n  C ^= a & c >> 4 ^ b & d >> 4;\n  D ^= b & c >> 4 ^ (a ^ b) & d >> 4;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  C ^= a & c >> 8 ^ b & d >> 8;\n  D ^= b & c >> 8 ^ (a ^ b) & d >> 8;\n  a = C ^ C >> 1;\n  b = D ^ D >> 1;\n  let i0 = x ^ y;\n  let i1 = b | 0xffff ^ (i0 | a);\n  i0 = (i0 | i0 << 8) & 0x00ff00ff;\n  i0 = (i0 | i0 << 4) & 0x0f0f0f0f;\n  i0 = (i0 | i0 << 2) & 0x33333333;\n  i0 = (i0 | i0 << 1) & 0x55555555;\n  i1 = (i1 | i1 << 8) & 0x00ff00ff;\n  i1 = (i1 | i1 << 4) & 0x0f0f0f0f;\n  i1 = (i1 | i1 << 2) & 0x33333333;\n  i1 = (i1 | i1 << 1) & 0x55555555;\n  return (i1 << 1 | i0) >>> 0;\n}","map":{"version":3,"names":["FlatQueue","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","VERSION","Flatbush","from","data","byteOffset","Error","byteLength","undefined","buffer","magic","versionAndType","version","ArrayType","nodeSize","numItems","constructor","ArrayBufferType","ArrayBuffer","isNaN","Math","min","max","n","numNodes","_levelBounds","ceil","push","IndexArrayType","arrayTypeIndex","indexOf","nodesByteSize","BYTES_PER_ELEMENT","_boxes","_indices","_pos","minX","minY","maxX","maxY","Infinity","set","_queue","add","index","boxes","finish","width","height","hilbertValues","hilbertMax","i","pos","x","floor","y","hilbert","sort","length","end","nodeIndex","nodeMinX","nodeMinY","nodeMaxX","nodeMaxY","j","search","filterFn","queue","results","upperBound","pop","neighbors","maxResults","maxDistSq","sqDistFn","sqDist","q","outer","dx","dy","dist","peek","peekValue","clear","value","arr","m","values","indices","left","right","start","mid","pivot","swap","temp","k","a","b","c","d","e","A","B","C","D","i0","i1"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-charts/esm/internals/Flatbush.js"],"sourcesContent":["// @ts-nocheck\n/* eslint-disable */\nimport FlatQueue from 'flatqueue';\nconst ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\nconst VERSION = 3; // serialized format version\n\nexport class Flatbush {\n  /**\n   * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.\n   * @param {ArrayBufferLike} data\n   * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.\n   * @returns {Flatbush} index\n   */\n  static from(data, byteOffset = 0) {\n    if (byteOffset % 8 !== 0) {\n      throw new Error('byteOffset must be 8-byte aligned.');\n    }\n\n    // @ts-expect-error duck typing array buffers\n    if (!data || data.byteLength === undefined || data.buffer) {\n      throw new Error('Data must be an instance of ArrayBuffer or SharedArrayBuffer.');\n    }\n    const [magic, versionAndType] = new Uint8Array(data, byteOffset + 0, 2);\n    if (magic !== 0xfb) {\n      throw new Error('Data does not appear to be in a Flatbush format.');\n    }\n    const version = versionAndType >> 4;\n    if (version !== VERSION) {\n      throw new Error(`Got v${version} data when expected v${VERSION}.`);\n    }\n    const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n    if (!ArrayType) {\n      throw new Error('Unrecognized array type.');\n    }\n    const [nodeSize] = new Uint16Array(data, byteOffset + 2, 1);\n    const [numItems] = new Uint32Array(data, byteOffset + 4, 1);\n    return new Flatbush(numItems, nodeSize, ArrayType, undefined, data, byteOffset);\n  }\n\n  /**\n   * Create a Flatbush index that will hold a given number of items.\n   * @param {number} numItems\n   * @param {number} [nodeSize=16] Size of the tree node (16 by default).\n   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n   * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).\n   * @param {ArrayBufferLike} [data] (Only used internally)\n   * @param {number} [byteOffset=0] (Only used internally)\n   */\n  constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data, byteOffset = 0) {\n    if (numItems === undefined) {\n      throw new Error('Missing required argument: numItems.');\n    }\n    if (isNaN(numItems) || numItems <= 0) {\n      throw new Error(`Unexpected numItems value: ${numItems}.`);\n    }\n    this.numItems = +numItems;\n    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    this.byteOffset = byteOffset;\n\n    // calculate the total number of nodes in the R-tree to allocate space for\n    // and the index of each tree level (used in search later)\n    let n = numItems;\n    let numNodes = n;\n    this._levelBounds = [n * 4];\n    do {\n      n = Math.ceil(n / this.nodeSize);\n      numNodes += n;\n      this._levelBounds.push(numNodes * 4);\n    } while (n !== 1);\n    this.ArrayType = ArrayType;\n    this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n    const arrayTypeIndex = ARRAY_TYPES.indexOf(ArrayType);\n    const nodesByteSize = numNodes * 4 * ArrayType.BYTES_PER_ELEMENT;\n    if (arrayTypeIndex < 0) {\n      throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n    }\n    if (data) {\n      this.data = data;\n      this._boxes = new ArrayType(data, byteOffset + 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(data, byteOffset + 8 + nodesByteSize, numNodes);\n      this._pos = numNodes * 4;\n      this.minX = this._boxes[this._pos - 4];\n      this.minY = this._boxes[this._pos - 3];\n      this.maxX = this._boxes[this._pos - 2];\n      this.maxY = this._boxes[this._pos - 1];\n    } else {\n      const data = this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n      this._boxes = new ArrayType(data, 8, numNodes * 4);\n      this._indices = new this.IndexArrayType(data, 8 + nodesByteSize, numNodes);\n      this._pos = 0;\n      this.minX = Infinity;\n      this.minY = Infinity;\n      this.maxX = -Infinity;\n      this.maxY = -Infinity;\n      new Uint8Array(data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n      new Uint16Array(data, 2, 1)[0] = nodeSize;\n      new Uint32Array(data, 4, 1)[0] = numItems;\n    }\n\n    // a priority queue for k-nearest-neighbors queries\n    /** @type FlatQueue<number> */\n    this._queue = new FlatQueue();\n  }\n\n  /**\n   * Add a given rectangle to the index.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @returns {number} A zero-based, incremental number that represents the newly added rectangle.\n   */\n  add(minX, minY, maxX = minX, maxY = minY) {\n    const index = this._pos >> 2;\n    const boxes = this._boxes;\n    this._indices[index] = index;\n    boxes[this._pos++] = minX;\n    boxes[this._pos++] = minY;\n    boxes[this._pos++] = maxX;\n    boxes[this._pos++] = maxY;\n    if (minX < this.minX) {\n      this.minX = minX;\n    }\n    if (minY < this.minY) {\n      this.minY = minY;\n    }\n    if (maxX > this.maxX) {\n      this.maxX = maxX;\n    }\n    if (maxY > this.maxY) {\n      this.maxY = maxY;\n    }\n    return index;\n  }\n\n  /** Perform indexing of the added rectangles. */\n  finish() {\n    if (this._pos >> 2 !== this.numItems) {\n      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n    }\n    const boxes = this._boxes;\n    if (this.numItems <= this.nodeSize) {\n      // only one node, skip sorting and just fill the root box\n      boxes[this._pos++] = this.minX;\n      boxes[this._pos++] = this.minY;\n      boxes[this._pos++] = this.maxX;\n      boxes[this._pos++] = this.maxY;\n      return;\n    }\n    const width = this.maxX - this.minX || 1;\n    const height = this.maxY - this.minY || 1;\n    const hilbertValues = new Uint32Array(this.numItems);\n    const hilbertMax = (1 << 16) - 1;\n\n    // map item centers into Hilbert coordinate space and calculate Hilbert values\n    for (let i = 0, pos = 0; i < this.numItems; i++) {\n      const minX = boxes[pos++];\n      const minY = boxes[pos++];\n      const maxX = boxes[pos++];\n      const maxY = boxes[pos++];\n      const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n      const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n      hilbertValues[i] = hilbert(x, y);\n    }\n\n    // sort items by their Hilbert value (for packing later)\n    sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\n\n    // generate nodes at each tree level, bottom-up\n    for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n      const end = this._levelBounds[i];\n\n      // generate a parent node for each block of consecutive <nodeSize> nodes\n      while (pos < end) {\n        const nodeIndex = pos;\n\n        // calculate bbox for the new node\n        let nodeMinX = boxes[pos++];\n        let nodeMinY = boxes[pos++];\n        let nodeMaxX = boxes[pos++];\n        let nodeMaxY = boxes[pos++];\n        for (let j = 1; j < this.nodeSize && pos < end; j++) {\n          nodeMinX = Math.min(nodeMinX, boxes[pos++]);\n          nodeMinY = Math.min(nodeMinY, boxes[pos++]);\n          nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);\n          nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);\n        }\n\n        // add the new node to the tree data\n        this._indices[this._pos >> 2] = nodeIndex;\n        boxes[this._pos++] = nodeMinX;\n        boxes[this._pos++] = nodeMinY;\n        boxes[this._pos++] = nodeMaxX;\n        boxes[this._pos++] = nodeMaxY;\n      }\n    }\n  }\n\n  /**\n   * Search the index by a bounding box.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n   * @returns {number[]} An array containing the index, the x coordinate and the y coordinate of the points intersecting or touching the given bounding box.\n   */\n  search(minX, minY, maxX, maxY, filterFn) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    /** @type number | undefined */\n    let nodeIndex = this._boxes.length - 4;\n    const queue = [];\n    const results = [];\n    while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n      // search through child nodes\n      for (let /** @type number */pos = nodeIndex; pos < end; pos += 4) {\n        // check if node bbox intersects with query bbox\n        if (maxX < this._boxes[pos]) {\n          continue;\n        } // maxX < nodeMinX\n        if (maxY < this._boxes[pos + 1]) {\n          continue;\n        } // maxY < nodeMinY\n        if (minX > this._boxes[pos + 2]) {\n          continue;\n        } // minX > nodeMaxX\n        if (minY > this._boxes[pos + 3]) {\n          continue;\n        } // minY > nodeMaxY\n\n        const index = this._indices[pos >> 2] | 0;\n        if (nodeIndex >= this.numItems * 4) {\n          queue.push(index); // node; add it to the search queue\n        } else if (filterFn === undefined || filterFn(index)) {\n          results.push(index);\n          results.push(this._boxes[pos]); // leaf item\n          results.push(this._boxes[pos + 1]);\n        }\n      }\n      nodeIndex = queue.pop();\n    }\n    return results;\n  }\n\n  /**\n   * Search items in order of distance from the given point.\n   * @param x\n   * @param y\n   * @param [maxResults=Infinity]\n   * @param maxDistSq\n   * @param [filterFn] An optional function for filtering the results.\n   * @param [sqDistFn] An optional function to calculate squared distance from the point to the item.\n   * @returns {number[]} An array of indices of items found.\n   */\n  neighbors(x, y, maxResults = Infinity, maxDistSq = Infinity, filterFn, sqDistFn = sqDist) {\n    if (this._pos !== this._boxes.length) {\n      throw new Error('Data not yet indexed - call index.finish().');\n    }\n\n    /** @type number | undefined */\n    let nodeIndex = this._boxes.length - 4;\n    const q = this._queue;\n    const results = [];\n\n    /* eslint-disable no-labels */\n    outer: while (nodeIndex !== undefined) {\n      // find the end index of the node\n      const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n      // add child nodes to the queue\n      for (let pos = nodeIndex; pos < end; pos += 4) {\n        const index = this._indices[pos >> 2] | 0;\n        const minX = this._boxes[pos];\n        const minY = this._boxes[pos + 1];\n        const maxX = this._boxes[pos + 2];\n        const maxY = this._boxes[pos + 3];\n        const dx = x < minX ? minX - x : x > maxX ? x - maxX : 0;\n        const dy = y < minY ? minY - y : y > maxY ? y - maxY : 0;\n        const dist = sqDistFn(dx, dy);\n        if (dist > maxDistSq) {\n          continue;\n        }\n        if (nodeIndex >= this.numItems * 4) {\n          q.push(index << 1, dist); // node (use even id)\n        } else if (filterFn === undefined || filterFn(index)) {\n          q.push((index << 1) + 1, dist); // leaf item (use odd id)\n        }\n      }\n\n      // pop items from the queue\n      // @ts-expect-error q.length check eliminates undefined values\n      while (q.length && q.peek() & 1) {\n        const dist = q.peekValue();\n\n        // @ts-expect-error\n        if (dist > maxDistSq) {\n          break outer;\n        }\n        // @ts-expect-error\n        results.push(q.pop() >> 1);\n        if (results.length === maxResults) {\n          break outer;\n        }\n      }\n\n      // @ts-expect-error\n      nodeIndex = q.length ? q.pop() >> 1 : undefined;\n    }\n    q.clear();\n    return results;\n  }\n}\nfunction sqDist(dx, dy) {\n  return dx * dx + dy * dy;\n}\n\n/**\n * Binary search for the first value in the array bigger than the given.\n * @param {number} value\n * @param {number[]} arr\n */\nfunction upperBound(value, arr) {\n  let i = 0;\n  let j = arr.length - 1;\n  while (i < j) {\n    const m = i + j >> 1;\n    if (arr[m] > value) {\n      j = m;\n    } else {\n      i = m + 1;\n    }\n  }\n  return arr[i];\n}\n\n/**\n * Custom quicksort that partially sorts bbox data alongside the hilbert values.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} left\n * @param {number} right\n * @param {number} nodeSize\n */\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n  if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) {\n    return;\n  }\n\n  // apply median of three method\n  const start = values[left];\n  const mid = values[left + right >> 1];\n  const end = values[right];\n  let pivot = end;\n  const x = Math.max(start, mid);\n  if (end > x) {\n    pivot = x;\n  } else if (x === start) {\n    pivot = Math.max(mid, end);\n  } else if (x === mid) {\n    pivot = Math.max(start, end);\n  }\n  let i = left - 1;\n  let j = right + 1;\n  while (true) {\n    do {\n      i++;\n    } while (values[i] < pivot);\n    do {\n      j--;\n    } while (values[j] > pivot);\n    if (i >= j) {\n      break;\n    }\n    swap(values, boxes, indices, i, j);\n  }\n  sort(values, boxes, indices, left, j, nodeSize);\n  sort(values, boxes, indices, j + 1, right, nodeSize);\n}\n\n/**\n * Swap two values and two corresponding boxes.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} i\n * @param {number} j\n */\nfunction swap(values, boxes, indices, i, j) {\n  const temp = values[i];\n  values[i] = values[j];\n  values[j] = temp;\n  const k = 4 * i;\n  const m = 4 * j;\n  const a = boxes[k];\n  const b = boxes[k + 1];\n  const c = boxes[k + 2];\n  const d = boxes[k + 3];\n  boxes[k] = boxes[m];\n  boxes[k + 1] = boxes[m + 1];\n  boxes[k + 2] = boxes[m + 2];\n  boxes[k + 3] = boxes[m + 3];\n  boxes[m] = a;\n  boxes[m + 1] = b;\n  boxes[m + 2] = c;\n  boxes[m + 3] = d;\n  const e = indices[i];\n  indices[i] = indices[j];\n  indices[j] = e;\n}\n\n/**\n * Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n * Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n * @param {number} x\n * @param {number} y\n */\nfunction hilbert(x, y) {\n  let a = x ^ y;\n  let b = 0xffff ^ a;\n  let c = 0xffff ^ (x | y);\n  let d = x & (y ^ 0xffff);\n  let A = a | b >> 1;\n  let B = a >> 1 ^ a;\n  let C = c >> 1 ^ b & d >> 1 ^ c;\n  let D = a & c >> 1 ^ d >> 1 ^ d;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 2 ^ b & b >> 2;\n  B = a & b >> 2 ^ b & (a ^ b) >> 2;\n  C ^= a & c >> 2 ^ b & d >> 2;\n  D ^= b & c >> 2 ^ (a ^ b) & d >> 2;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  A = a & a >> 4 ^ b & b >> 4;\n  B = a & b >> 4 ^ b & (a ^ b) >> 4;\n  C ^= a & c >> 4 ^ b & d >> 4;\n  D ^= b & c >> 4 ^ (a ^ b) & d >> 4;\n  a = A;\n  b = B;\n  c = C;\n  d = D;\n  C ^= a & c >> 8 ^ b & d >> 8;\n  D ^= b & c >> 8 ^ (a ^ b) & d >> 8;\n  a = C ^ C >> 1;\n  b = D ^ D >> 1;\n  let i0 = x ^ y;\n  let i1 = b | 0xffff ^ (i0 | a);\n  i0 = (i0 | i0 << 8) & 0x00ff00ff;\n  i0 = (i0 | i0 << 4) & 0x0f0f0f0f;\n  i0 = (i0 | i0 << 2) & 0x33333333;\n  i0 = (i0 | i0 << 1) & 0x55555555;\n  i1 = (i1 | i1 << 8) & 0x00ff00ff;\n  i1 = (i1 | i1 << 4) & 0x0f0f0f0f;\n  i1 = (i1 | i1 << 2) & 0x33333333;\n  i1 = (i1 | i1 << 1) & 0x55555555;\n  return (i1 << 1 | i0) >>> 0;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}