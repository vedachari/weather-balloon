{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapAndDragGesture - Detects tap followed by drag gestures using composition\n *\n * This gesture uses internal TapGesture and PanGesture instances to:\n * 1. First, detect a tap (quick touch without movement)\n * 2. Then, track drag movements on the next pointer down\n *\n * The gesture fires events when:\n * - A tap is completed (tap phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { TapGesture } from \"./TapGesture.js\";\n\n/**\n * Configuration options for TapAndDragGesture\n * Extends PointerGestureOptions with tap and drag specific settings\n */\n\n/**\n * Event data specific to tap and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by TapAndDragGesture\n */\n\n/**\n * Represents the current phase of the TapAndDrag gesture\n */\n\n/**\n * State tracking for the TapAndDragGesture\n */\n\n/**\n * TapAndDragGesture class for handling tap followed by drag interactions\n *\n * This gesture composes tap and drag logic patterns from TapGesture and PanGesture\n * into a single coordinated gesture that handles tap-then-drag interactions.\n */\nexport class TapAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForTap',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Maximum distance a pointer can move during tap for it to still be considered a tap\n   * (Following TapGesture pattern)\n   */\n\n  /**\n   * Maximum time between tap completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.tapGesture = new TapGesture({\n      name: `${this.name}-tap`,\n      maxDistance: this.tapMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new TapAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      tapMaxDistance: this.tapMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.tapGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.element.addEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.tapGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? this.tapMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.tapGesture.name}ChangeOptions`, {\n      detail: {\n        maxDistance: this.tapMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForTap',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the TapAndDragGesture relies on TapGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  tapHandler = () => {\n    if (this.state.phase !== 'waitingForTap') {\n      return;\n    }\n    this.state.phase = 'tapDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'tapDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","createEventName","preventDefault","PanGesture","TapGesture","TapAndDragGesture","state","phase","dragTimeoutId","constructor","options","tapMaxDistance","dragTimeout","dragThreshold","dragDirection","tapGesture","name","maxDistance","maxPointers","pointerMode","requiredKeys","preventIf","pointerOptions","structuredClone","panGesture","minPointers","threshold","direction","clone","overrides","stopPropagation","init","element","pointerManager","gestureRegistry","keyboardManager","addEventListener","tapHandler","dragStartHandler","dragMoveHandler","dragEndHandler","destroy","resetState","removeEventListener","updateOptions","dispatchEvent","CustomEvent","detail","clearTimeout","restoreTouchAction","isActive","handlePointerEvent","setTouchAction","setTimeout","event","passive"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/TapAndDragGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * TapAndDragGesture - Detects tap followed by drag gestures using composition\n *\n * This gesture uses internal TapGesture and PanGesture instances to:\n * 1. First, detect a tap (quick touch without movement)\n * 2. Then, track drag movements on the next pointer down\n *\n * The gesture fires events when:\n * - A tap is completed (tap phase)\n * - Drag movement begins and passes threshold (dragStart)\n * - Drag movement continues (drag)\n * - Drag movement ends (dragEnd)\n * - The gesture is canceled at any point\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { createEventName, preventDefault } from \"../utils/index.js\";\nimport { PanGesture } from \"./PanGesture.js\";\nimport { TapGesture } from \"./TapGesture.js\";\n\n/**\n * Configuration options for TapAndDragGesture\n * Extends PointerGestureOptions with tap and drag specific settings\n */\n\n/**\n * Event data specific to tap and drag gesture events\n * Contains information about the gesture state, position, and movement\n */\n\n/**\n * Type definition for the CustomEvent created by TapAndDragGesture\n */\n\n/**\n * Represents the current phase of the TapAndDrag gesture\n */\n\n/**\n * State tracking for the TapAndDragGesture\n */\n\n/**\n * TapAndDragGesture class for handling tap followed by drag interactions\n *\n * This gesture composes tap and drag logic patterns from TapGesture and PanGesture\n * into a single coordinated gesture that handles tap-then-drag interactions.\n */\nexport class TapAndDragGesture extends PointerGesture {\n  state = {\n    phase: 'waitingForTap',\n    dragTimeoutId: null\n  };\n\n  /**\n   * Maximum distance a pointer can move during tap for it to still be considered a tap\n   * (Following TapGesture pattern)\n   */\n\n  /**\n   * Maximum time between tap completion and drag start\n   */\n\n  /**\n   * Movement threshold for drag activation\n   */\n\n  /**\n   * Allowed directions for the drag gesture\n   */\n\n  constructor(options) {\n    super(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? 10;\n    this.dragTimeout = options.dragTimeout ?? 1000;\n    this.dragThreshold = options.dragThreshold ?? 0;\n    this.dragDirection = options.dragDirection || ['up', 'down', 'left', 'right'];\n    this.tapGesture = new TapGesture({\n      name: `${this.name}-tap`,\n      maxDistance: this.tapMaxDistance,\n      maxPointers: this.maxPointers,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n    this.panGesture = new PanGesture({\n      name: `${this.name}-pan`,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      threshold: this.dragThreshold,\n      direction: this.dragDirection,\n      pointerMode: this.pointerMode,\n      requiredKeys: this.requiredKeys,\n      preventIf: this.preventIf,\n      pointerOptions: structuredClone(this.pointerOptions)\n    });\n  }\n  clone(overrides) {\n    return new TapAndDragGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      tapMaxDistance: this.tapMaxDistance,\n      dragTimeout: this.dragTimeout,\n      dragThreshold: this.dragThreshold,\n      dragDirection: [...this.dragDirection],\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  init(element, pointerManager, gestureRegistry, keyboardManager) {\n    super.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.tapGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.panGesture.init(element, pointerManager, gestureRegistry, keyboardManager);\n    this.element.addEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.addEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n  }\n  destroy() {\n    this.resetState();\n    this.tapGesture.destroy();\n    this.panGesture.destroy();\n    this.element.removeEventListener(this.tapGesture.name, this.tapHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Start`, this.dragStartHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(this.panGesture.name, this.dragMoveHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}End`, this.dragEndHandler);\n    // @ts-expect-error, PointerEvent is correct.\n    this.element.removeEventListener(`${this.panGesture.name}Cancel`, this.dragEndHandler);\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n    this.tapMaxDistance = options.tapMaxDistance ?? this.tapMaxDistance;\n    this.dragTimeout = options.dragTimeout ?? this.dragTimeout;\n    this.dragThreshold = options.dragThreshold ?? this.dragThreshold;\n    this.dragDirection = options.dragDirection || this.dragDirection;\n    this.element.dispatchEvent(new CustomEvent(`${this.panGesture.name}ChangeOptions`, {\n      detail: {\n        minPointers: this.minPointers,\n        maxPointers: this.maxPointers,\n        threshold: this.dragThreshold,\n        direction: this.dragDirection,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n    this.element.dispatchEvent(new CustomEvent(`${this.tapGesture.name}ChangeOptions`, {\n      detail: {\n        maxDistance: this.tapMaxDistance,\n        maxPointers: this.maxPointers,\n        pointerMode: this.pointerMode,\n        requiredKeys: this.requiredKeys,\n        preventIf: this.preventIf,\n        pointerOptions: structuredClone(this.pointerOptions)\n      }\n    }));\n  }\n  resetState() {\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n    }\n    this.restoreTouchAction();\n    this.isActive = false;\n    this.state = {\n      phase: 'waitingForTap',\n      dragTimeoutId: null\n    };\n  }\n\n  /**\n   * This can be empty because the TapAndDragGesture relies on TapGesture and PanGesture to handle pointer events\n   * The internal gestures will manage their own state and events, while this class coordinates between them\n   */\n  handlePointerEvent() {}\n  tapHandler = () => {\n    if (this.state.phase !== 'waitingForTap') {\n      return;\n    }\n    this.state.phase = 'tapDetected';\n    this.setTouchAction();\n\n    // Start timeout to wait for drag start\n    this.state.dragTimeoutId = setTimeout(() => {\n      // Timeout expired, reset gesture\n      this.resetState();\n    }, this.dragTimeout);\n  };\n  dragStartHandler = event => {\n    if (this.state.phase !== 'tapDetected') {\n      return;\n    }\n\n    // Clear the drag timeout as drag has started\n    if (this.state.dragTimeoutId !== null) {\n      clearTimeout(this.state.dragTimeoutId);\n      this.state.dragTimeoutId = null;\n    }\n    this.restoreTouchAction();\n    this.state.phase = 'dragging';\n    this.isActive = true;\n\n    // Fire start event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragMoveHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n\n    // Fire move event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  dragEndHandler = event => {\n    if (this.state.phase !== 'dragging') {\n      return;\n    }\n    this.resetState();\n\n    // Fire end event\n    this.element.dispatchEvent(new CustomEvent(createEventName(this.name, event.detail.phase), event));\n  };\n  setTouchAction() {\n    this.element.addEventListener('touchstart', preventDefault, {\n      passive: false\n    });\n  }\n  restoreTouchAction() {\n    this.element.removeEventListener('touchstart', preventDefault);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}