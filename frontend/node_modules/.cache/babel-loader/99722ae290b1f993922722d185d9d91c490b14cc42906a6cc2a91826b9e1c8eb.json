{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * RotateGesture - Detects rotation movements between two or more pointers\n *\n * This gesture tracks when multiple pointers rotate around a common center point, firing events when:\n * - Two or more pointers begin a rotation motion (start)\n * - The pointers continue rotating (ongoing)\n * - One or more pointers are released or lifted (end)\n *\n * This gesture is commonly used for rotation controls in drawing or image manipulation interfaces.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, calculateRotationAngle, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for the RotateGesture\n * Uses the same options as the base PointerGesture\n */\n\n/**\n * Event data specific to rotate gesture events\n * Contains information about rotation angle, delta, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by RotateGesture\n */\n\n/**\n * State tracking for the RotateGesture\n */\n\n/**\n * RotateGesture class for handling rotation interactions\n *\n * This gesture detects when users rotate multiple pointers around a central point,\n * and dispatches rotation-related events with angle and angular velocity information.\n */\nexport class RotateGesture extends PointerGesture {\n  state = {\n    startAngle: 0,\n    lastAngle: 0,\n    totalRotation: 0,\n    lastTime: 0,\n    velocity: 0,\n    lastDelta: 0\n  };\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(options) {\n    super(options);\n  }\n  clone(overrides) {\n    return new RotateGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startAngle: 0,\n      lastAngle: 0,\n      lastTime: 0,\n      velocity: 0,\n      lastDelta: 0\n    });\n  }\n\n  /**\n   * Handle pointer events for the rotate gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, end it gracefully\n        this.emitRotateEvent(targetElement, 'cancel', pointersArray, event);\n        this.resetState();\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n\n    // Check if we have enough pointers for a rotation (at least 2)\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // End the gesture if it was active\n        this.emitRotateEvent(targetElement, 'end', relevantPointers, event);\n        this.resetState();\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (relevantPointers.length >= 2 && !this.isActive) {\n          // Calculate and store the starting angle\n          const initialAngle = calculateRotationAngle(relevantPointers);\n          this.state.startAngle = initialAngle;\n          this.state.lastAngle = initialAngle;\n          this.state.lastTime = event.timeStamp;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (relevantPointers.length >= 2) {\n          // Calculate current rotation angle\n          const currentAngle = calculateRotationAngle(relevantPointers);\n\n          // Calculate rotation delta (change in angle)\n          let delta = currentAngle - this.state.lastAngle;\n\n          // Adjust for angle wrapping (event.g., from 359° to 0°)\n          if (delta > 180) {\n            delta -= 360;\n          }\n          if (delta < -180) {\n            delta += 360;\n          }\n\n          // Store the delta for use in emitRotateEvent\n          this.state.lastDelta = delta;\n\n          // Update rotation value (cumulative)\n          this.state.totalRotation += delta;\n\n          // Calculate angular velocity (degrees per second)\n          const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\n          if (deltaTime > 0) {\n            this.state.velocity = delta / deltaTime;\n          }\n\n          // Update state\n          this.state.lastAngle = currentAngle;\n          this.state.lastTime = event.timeStamp;\n\n          // Emit ongoing event if there's an actual rotation\n          // We don't want to emit events for tiny movements that might be just noise\n          if (Math.abs(delta) <= 0.1) {\n            return;\n          }\n          if (!this.isActive) {\n            this.isActive = true;\n            // Emit start event\n            this.emitRotateEvent(targetElement, 'start', relevantPointers, event);\n            this.emitRotateEvent(targetElement, 'ongoing', relevantPointers, event);\n          } else {\n            this.emitRotateEvent(targetElement, 'ongoing', relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        if (this.isActive) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            if (event.type === 'pointercancel') {\n              this.emitRotateEvent(targetElement, 'cancel', relevantPointers, event);\n            }\n            this.emitRotateEvent(targetElement, 'end', relevantPointers, event);\n\n            // Reset state\n            this.resetState();\n          } else if (remainingPointers.length >= 2) {\n            // If we still have enough pointers, update the start angle\n            // to prevent jumping when a finger is lifted\n            const newAngle = calculateRotationAngle(remainingPointers);\n            this.state.startAngle = newAngle - this.state.totalRotation;\n            this.state.lastAngle = newAngle;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit rotate-specific events with additional data\n   */\n  emitRotateEvent(element, phase, pointers, event) {\n    // Calculate current centroid\n    const centroid = calculateCentroid(pointers);\n\n    // Create custom event data\n    const rotation = this.state.totalRotation;\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      rotation,\n      delta: this.state.lastDelta,\n      totalRotation: this.state.totalRotation,\n      velocity: this.state.velocity,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Handle default event behavior\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}","map":{"version":3,"names":["_extends","PointerGesture","calculateCentroid","calculateRotationAngle","createEventName","RotateGesture","state","startAngle","lastAngle","totalRotation","lastTime","velocity","lastDelta","constructor","options","clone","overrides","name","preventDefault","stopPropagation","minPointers","maxPointers","requiredKeys","pointerMode","preventIf","pointerOptions","structuredClone","destroy","resetState","updateOptions","isActive","handlePointerEvent","pointers","event","pointersArray","Array","from","values","targetElement","getTargetElement","shouldPreventGesture","pointerType","emitRotateEvent","relevantPointers","getRelevantPointers","isWithinPointerCount","type","length","initialAngle","timeStamp","originalTarget","currentAngle","delta","deltaTime","Math","abs","remainingPointers","filter","p","newAngle","element","phase","centroid","rotation","activeGestures","gesturesRegistry","getActiveGestures","customEventData","gestureName","target","srcEvent","customData","eventName","domEvent","CustomEvent","bubbles","cancelable","composed","detail","dispatchEvent"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/gestures/RotateGesture.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * RotateGesture - Detects rotation movements between two or more pointers\n *\n * This gesture tracks when multiple pointers rotate around a common center point, firing events when:\n * - Two or more pointers begin a rotation motion (start)\n * - The pointers continue rotating (ongoing)\n * - One or more pointers are released or lifted (end)\n *\n * This gesture is commonly used for rotation controls in drawing or image manipulation interfaces.\n */\n\nimport { PointerGesture } from \"../PointerGesture.js\";\nimport { calculateCentroid, calculateRotationAngle, createEventName } from \"../utils/index.js\";\n\n/**\n * Configuration options for the RotateGesture\n * Uses the same options as the base PointerGesture\n */\n\n/**\n * Event data specific to rotate gesture events\n * Contains information about rotation angle, delta, and velocity\n */\n\n/**\n * Type definition for the CustomEvent created by RotateGesture\n */\n\n/**\n * State tracking for the RotateGesture\n */\n\n/**\n * RotateGesture class for handling rotation interactions\n *\n * This gesture detects when users rotate multiple pointers around a central point,\n * and dispatches rotation-related events with angle and angular velocity information.\n */\nexport class RotateGesture extends PointerGesture {\n  state = {\n    startAngle: 0,\n    lastAngle: 0,\n    totalRotation: 0,\n    lastTime: 0,\n    velocity: 0,\n    lastDelta: 0\n  };\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(options) {\n    super(options);\n  }\n  clone(overrides) {\n    return new RotateGesture(_extends({\n      name: this.name,\n      preventDefault: this.preventDefault,\n      stopPropagation: this.stopPropagation,\n      minPointers: this.minPointers,\n      maxPointers: this.maxPointers,\n      requiredKeys: [...this.requiredKeys],\n      pointerMode: [...this.pointerMode],\n      preventIf: [...this.preventIf],\n      pointerOptions: structuredClone(this.pointerOptions)\n    }, overrides));\n  }\n  destroy() {\n    this.resetState();\n    super.destroy();\n  }\n  updateOptions(options) {\n    super.updateOptions(options);\n  }\n  resetState() {\n    this.isActive = false;\n    this.state = _extends({}, this.state, {\n      startAngle: 0,\n      lastAngle: 0,\n      lastTime: 0,\n      velocity: 0,\n      lastDelta: 0\n    });\n  }\n\n  /**\n   * Handle pointer events for the rotate gesture\n   */\n  handlePointerEvent = (pointers, event) => {\n    const pointersArray = Array.from(pointers.values());\n\n    // Find which element (if any) is being targeted\n    const targetElement = this.getTargetElement(event);\n    if (!targetElement) {\n      return;\n    }\n\n    // Check if this gesture should be prevented by active gestures\n    if (this.shouldPreventGesture(targetElement, event.pointerType)) {\n      if (this.isActive) {\n        // If the gesture was active but now should be prevented, end it gracefully\n        this.emitRotateEvent(targetElement, 'cancel', pointersArray, event);\n        this.resetState();\n      }\n      return;\n    }\n\n    // Filter pointers to only include those targeting our element or its children\n    const relevantPointers = this.getRelevantPointers(pointersArray, targetElement);\n\n    // Check if we have enough pointers for a rotation (at least 2)\n    if (!this.isWithinPointerCount(relevantPointers, event.pointerType)) {\n      if (this.isActive) {\n        // End the gesture if it was active\n        this.emitRotateEvent(targetElement, 'end', relevantPointers, event);\n        this.resetState();\n      }\n      return;\n    }\n    switch (event.type) {\n      case 'pointerdown':\n        if (relevantPointers.length >= 2 && !this.isActive) {\n          // Calculate and store the starting angle\n          const initialAngle = calculateRotationAngle(relevantPointers);\n          this.state.startAngle = initialAngle;\n          this.state.lastAngle = initialAngle;\n          this.state.lastTime = event.timeStamp;\n\n          // Store the original target element\n          this.originalTarget = targetElement;\n        }\n        break;\n      case 'pointermove':\n        if (relevantPointers.length >= 2) {\n          // Calculate current rotation angle\n          const currentAngle = calculateRotationAngle(relevantPointers);\n\n          // Calculate rotation delta (change in angle)\n          let delta = currentAngle - this.state.lastAngle;\n\n          // Adjust for angle wrapping (event.g., from 359° to 0°)\n          if (delta > 180) {\n            delta -= 360;\n          }\n          if (delta < -180) {\n            delta += 360;\n          }\n\n          // Store the delta for use in emitRotateEvent\n          this.state.lastDelta = delta;\n\n          // Update rotation value (cumulative)\n          this.state.totalRotation += delta;\n\n          // Calculate angular velocity (degrees per second)\n          const deltaTime = (event.timeStamp - this.state.lastTime) / 1000; // convert to seconds\n          if (deltaTime > 0) {\n            this.state.velocity = delta / deltaTime;\n          }\n\n          // Update state\n          this.state.lastAngle = currentAngle;\n          this.state.lastTime = event.timeStamp;\n\n          // Emit ongoing event if there's an actual rotation\n          // We don't want to emit events for tiny movements that might be just noise\n          if (Math.abs(delta) <= 0.1) {\n            return;\n          }\n          if (!this.isActive) {\n            this.isActive = true;\n            // Emit start event\n            this.emitRotateEvent(targetElement, 'start', relevantPointers, event);\n            this.emitRotateEvent(targetElement, 'ongoing', relevantPointers, event);\n          } else {\n            this.emitRotateEvent(targetElement, 'ongoing', relevantPointers, event);\n          }\n        }\n        break;\n      case 'pointerup':\n      case 'pointercancel':\n      case 'forceCancel':\n        if (this.isActive) {\n          const remainingPointers = relevantPointers.filter(p => p.type !== 'pointerup' && p.type !== 'pointercancel');\n\n          // If we no longer meet the pointer count requirements, end the gesture\n          if (!this.isWithinPointerCount(remainingPointers, event.pointerType)) {\n            if (event.type === 'pointercancel') {\n              this.emitRotateEvent(targetElement, 'cancel', relevantPointers, event);\n            }\n            this.emitRotateEvent(targetElement, 'end', relevantPointers, event);\n\n            // Reset state\n            this.resetState();\n          } else if (remainingPointers.length >= 2) {\n            // If we still have enough pointers, update the start angle\n            // to prevent jumping when a finger is lifted\n            const newAngle = calculateRotationAngle(remainingPointers);\n            this.state.startAngle = newAngle - this.state.totalRotation;\n            this.state.lastAngle = newAngle;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Emit rotate-specific events with additional data\n   */\n  emitRotateEvent(element, phase, pointers, event) {\n    // Calculate current centroid\n    const centroid = calculateCentroid(pointers);\n\n    // Create custom event data\n    const rotation = this.state.totalRotation;\n\n    // Get list of active gestures\n    const activeGestures = this.gesturesRegistry.getActiveGestures(element);\n    const customEventData = {\n      gestureName: this.name,\n      centroid,\n      target: event.target,\n      srcEvent: event,\n      phase,\n      pointers,\n      timeStamp: event.timeStamp,\n      rotation,\n      delta: this.state.lastDelta,\n      totalRotation: this.state.totalRotation,\n      velocity: this.state.velocity,\n      activeGestures,\n      customData: this.customData\n    };\n\n    // Handle default event behavior\n    if (this.preventDefault) {\n      event.preventDefault();\n    }\n    if (this.stopPropagation) {\n      event.stopPropagation();\n    }\n\n    // Event names to trigger\n    const eventName = createEventName(this.name, phase);\n\n    // Dispatch custom events on the element\n    const domEvent = new CustomEvent(eventName, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail: customEventData\n    });\n    element.dispatchEvent(domEvent);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}