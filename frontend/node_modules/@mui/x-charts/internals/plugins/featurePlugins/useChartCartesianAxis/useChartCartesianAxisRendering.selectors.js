"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectorDefaultYAxisTickNumber = exports.selectorDefaultXAxisTickNumber = exports.selectorChartZoomOptionsLookup = exports.selectorChartZoomMap = exports.selectorChartZoomIsInteracting = exports.selectorChartZoomAxisFilters = exports.selectorChartYScales = exports.selectorChartYDomains = exports.selectorChartYAxis = exports.selectorChartXScales = exports.selectorChartXDomains = exports.selectorChartXAxis = exports.selectorChartSeriesFlatbushMap = exports.selectorChartSeriesEmptyFlatbushMap = exports.selectorChartRawAxis = exports.selectorChartNormalizedYScales = exports.selectorChartNormalizedXScales = exports.selectorChartFilteredYDomains = exports.selectorChartFilteredXDomains = exports.selectorChartDefaultYAxisId = exports.selectorChartDefaultXAxisId = exports.selectorChartAxisZoomOptionsLookup = exports.selectorChartAxisZoomData = exports.selectorChartAxis = exports.createZoomMap = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _isDeepEqual = require("@mui/x-internals/isDeepEqual");
var _useChartDimensions = require("../../corePlugins/useChartDimensions");
var _useChartSeries = require("../../corePlugins/useChartSeries");
var _selectors = require("../../utils/selectors");
var _computeAxisValue = require("./computeAxisValue");
var _createAxisFilterMapper = require("./createAxisFilterMapper");
var _createZoomLookup = require("./createZoomLookup");
var _axis = require("../../../../models/axis");
var _useChartCartesianAxisLayout = require("./useChartCartesianAxisLayout.selectors");
var _useChartExperimentalFeature = require("../../corePlugins/useChartExperimentalFeature");
var _ticks = require("../../../ticks");
var _getAxisScale = require("./getAxisScale");
var _scaleGuards = require("../../../scaleGuards");
var _zoom = require("./zoom");
var _getAxisExtrema = require("./getAxisExtrema");
var _domain = require("./domain");
var _Flatbush = require("../../../Flatbush");
const createZoomMap = zoom => {
  const zoomItemMap = new Map();
  zoom.forEach(zoomItem => {
    zoomItemMap.set(zoomItem.axisId, zoomItem);
  });
  return zoomItemMap;
};
exports.createZoomMap = createZoomMap;
const selectorChartZoomState = state => state.zoom;

/**
 * Following selectors are not exported because they exist in the MIT chart only to ba able to reuse the Zoom state from the pro.
 */

const selectorChartZoomIsInteracting = exports.selectorChartZoomIsInteracting = (0, _selectors.createSelector)([selectorChartZoomState], zoom => zoom?.isInteracting);
const selectorChartZoomMap = exports.selectorChartZoomMap = (0, _selectors.createSelector)([selectorChartZoomState], zoom => zoom?.zoomData && createZoomMap(zoom?.zoomData));
const selectorChartAxisZoomData = exports.selectorChartAxisZoomData = (0, _selectors.createSelector)([selectorChartZoomMap, (_, axisId) => axisId], (zoomMap, axisId) => zoomMap?.get(axisId));
const selectorChartZoomOptionsLookup = exports.selectorChartZoomOptionsLookup = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartCartesianAxisLayout.selectorChartRawYAxis], (xAxis, yAxis) => (0, _extends2.default)({}, (0, _createZoomLookup.createZoomLookup)('x')(xAxis), (0, _createZoomLookup.createZoomLookup)('y')(yAxis)));
const selectorChartAxisZoomOptionsLookup = exports.selectorChartAxisZoomOptionsLookup = (0, _selectors.createSelector)([selectorChartZoomOptionsLookup, (_, axisId) => axisId], (axisLookup, axisId) => axisLookup[axisId]);
const selectorDefaultXAxisTickNumber = exports.selectorDefaultXAxisTickNumber = (0, _selectors.createSelector)([_useChartDimensions.selectorChartDrawingArea], function selectorDefaultXAxisTickNumber(drawingArea) {
  return (0, _ticks.getDefaultTickNumber)(drawingArea.width);
});
const selectorDefaultYAxisTickNumber = exports.selectorDefaultYAxisTickNumber = (0, _selectors.createSelector)([_useChartDimensions.selectorChartDrawingArea], function selectorDefaultYAxisTickNumber(drawingArea) {
  return (0, _ticks.getDefaultTickNumber)(drawingArea.height);
});
const selectorChartXDomains = exports.selectorChartXDomains = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, _useChartExperimentalFeature.selectorPreferStrictDomainInLineCharts, selectorDefaultXAxisTickNumber], function selectorChartXDomains(axes, formattedSeries, seriesConfig, preferStrictDomainInLineCharts, defaultTickNumber) {
  const axisDirection = 'x';
  const domains = {};
  axes?.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    if ((0, _axis.isBandScaleConfig)(axis) || (0, _axis.isPointScaleConfig)(axis)) {
      domains[axis.id] = {
        domain: axis.data
      };
      return;
    }
    const axisExtrema = (0, _getAxisExtrema.getAxisExtrema)(axis, axisDirection, seriesConfig, axisIndex, formattedSeries);
    domains[axis.id] = (0, _domain.calculateInitialDomainAndTickNumber)(axis, 'x', axisIndex, formattedSeries, axisExtrema, defaultTickNumber, preferStrictDomainInLineCharts);
  });
  return domains;
});
const selectorChartYDomains = exports.selectorChartYDomains = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, _useChartExperimentalFeature.selectorPreferStrictDomainInLineCharts, selectorDefaultYAxisTickNumber], function selectorChartYDomains(axes, formattedSeries, seriesConfig, preferStrictDomainInLineCharts, defaultTickNumber) {
  const axisDirection = 'y';
  const domains = {};
  axes?.forEach((eachAxis, axisIndex) => {
    const axis = eachAxis;
    if ((0, _axis.isBandScaleConfig)(axis) || (0, _axis.isPointScaleConfig)(axis)) {
      domains[axis.id] = {
        domain: axis.data
      };
      return;
    }
    const axisExtrema = (0, _getAxisExtrema.getAxisExtrema)(axis, axisDirection, seriesConfig, axisIndex, formattedSeries);
    domains[axis.id] = (0, _domain.calculateInitialDomainAndTickNumber)(axis, 'y', axisIndex, formattedSeries, axisExtrema, defaultTickNumber, preferStrictDomainInLineCharts);
  });
  return domains;
});
const selectorChartZoomAxisFilters = exports.selectorChartZoomAxisFilters = (0, _selectors.createSelector)([selectorChartZoomMap, selectorChartZoomOptionsLookup, _useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartCartesianAxisLayout.selectorChartRawYAxis, selectorChartXDomains, selectorChartYDomains], (zoomMap, zoomOptions, xAxis, yAxis, xDomains, yDomains) => {
  if (!zoomMap || !zoomOptions) {
    return undefined;
  }
  let hasFilter = false;
  const filters = {};
  const axes = [...(xAxis ?? []), ...(yAxis ?? [])];
  for (let i = 0; i < axes.length; i += 1) {
    const axis = axes[i];
    if (!zoomOptions[axis.id] || zoomOptions[axis.id].filterMode !== 'discard') {
      continue;
    }
    const zoom = zoomMap.get(axis.id);
    if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {
      // No zoom, or zoom with all data visible
      continue;
    }
    const axisDirection = i < (xAxis?.length ?? 0) ? 'x' : 'y';
    if (axis.scaleType === 'band' || axis.scaleType === 'point') {
      filters[axis.id] = (0, _createAxisFilterMapper.createDiscreteScaleGetAxisFilter)(axis.data, zoom.start, zoom.end, axisDirection);
    } else {
      const {
        domain
      } = axisDirection === 'x' ? xDomains[axis.id] : yDomains[axis.id];
      filters[axis.id] = (0, _createAxisFilterMapper.createContinuousScaleGetAxisFilter)(
      // For continuous scales, the domain is always a two-value array.
      domain, zoom.start, zoom.end, axisDirection, axis.data);
    }
    hasFilter = true;
  }
  if (!hasFilter) {
    return undefined;
  }
  return (0, _createAxisFilterMapper.createGetAxisFilters)(filters);
});
const selectorChartFilteredXDomains = exports.selectorChartFilteredXDomains = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters, _useChartExperimentalFeature.selectorPreferStrictDomainInLineCharts, selectorChartXDomains], (axes, formattedSeries, seriesConfig, zoomMap, zoomOptions, getFilters, preferStrictDomainInLineCharts, domains) => {
  const filteredDomains = {};
  axes?.forEach((axis, axisIndex) => {
    const domain = domains[axis.id].domain;
    if ((0, _axis.isBandScaleConfig)(axis) || (0, _axis.isPointScaleConfig)(axis)) {
      filteredDomains[axis.id] = domain;
      return;
    }
    const zoom = zoomMap?.get(axis.id);
    const zoomOption = zoomOptions?.[axis.id];
    const filter = zoom === undefined && !zoomOption ? getFilters : undefined; // Do not apply filtering if zoom is already defined.

    if (!filter) {
      filteredDomains[axis.id] = domain;
      return;
    }
    const rawTickNumber = domains[axis.id].tickNumber;
    const axisExtrema = (0, _getAxisExtrema.getAxisExtrema)(axis, 'x', seriesConfig, axisIndex, formattedSeries, filter);
    filteredDomains[axis.id] = (0, _domain.calculateFinalDomain)(axis, 'x', axisIndex, formattedSeries, axisExtrema, rawTickNumber, preferStrictDomainInLineCharts);
  });
  return filteredDomains;
}, {
  memoizeOptions: {
    resultEqualityCheck: (a, b) => (0, _isDeepEqual.isDeepEqual)(a, b)
  }
});
const selectorChartFilteredYDomains = exports.selectorChartFilteredYDomains = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartZoomOptionsLookup, selectorChartZoomAxisFilters, _useChartExperimentalFeature.selectorPreferStrictDomainInLineCharts, selectorChartYDomains], (axes, formattedSeries, seriesConfig, zoomMap, zoomOptions, getFilters, preferStrictDomainInLineCharts, domains) => {
  const filteredDomains = {};
  axes?.forEach((axis, axisIndex) => {
    const domain = domains[axis.id].domain;
    if ((0, _axis.isBandScaleConfig)(axis) || (0, _axis.isPointScaleConfig)(axis)) {
      filteredDomains[axis.id] = domain;
      return;
    }
    const zoom = zoomMap?.get(axis.id);
    const zoomOption = zoomOptions?.[axis.id];
    const filter = zoom === undefined && !zoomOption ? getFilters : undefined; // Do not apply filtering if zoom is already defined.

    if (!filter) {
      filteredDomains[axis.id] = domain;
      return;
    }
    const rawTickNumber = domains[axis.id].tickNumber;
    const axisExtrema = (0, _getAxisExtrema.getAxisExtrema)(axis, 'y', seriesConfig, axisIndex, formattedSeries, filter);
    filteredDomains[axis.id] = (0, _domain.calculateFinalDomain)(axis, 'y', axisIndex, formattedSeries, axisExtrema, rawTickNumber, preferStrictDomainInLineCharts);
  });
  return filteredDomains;
}, {
  memoizeOptions: {
    resultEqualityCheck: (a, b) => (0, _isDeepEqual.isDeepEqual)(a, b)
  }
});
const selectorChartNormalizedXScales = exports.selectorChartNormalizedXScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, selectorChartFilteredXDomains], function selectorChartNormalizedXScales(axes, filteredDomains) {
  const scales = {};
  axes?.forEach(eachAxis => {
    const axis = eachAxis;
    const domain = filteredDomains[axis.id];
    scales[axis.id] = (0, _getAxisScale.getNormalizedAxisScale)(axis, domain);
  });
  return scales;
});
const selectorChartNormalizedYScales = exports.selectorChartNormalizedYScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, selectorChartFilteredYDomains], function selectorChartNormalizedYScales(axes, filteredDomains) {
  const scales = {};
  axes?.forEach(eachAxis => {
    const axis = eachAxis;
    const domain = filteredDomains[axis.id];
    scales[axis.id] = (0, _getAxisScale.getNormalizedAxisScale)(axis, domain);
  });
  return scales;
});
const selectorChartXScales = exports.selectorChartXScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, selectorChartNormalizedXScales, _useChartDimensions.selectorChartDrawingArea, selectorChartZoomMap], function selectorChartXScales(axes, normalizedScales, drawingArea, zoomMap) {
  const scales = {};
  axes?.forEach(eachAxis => {
    const axis = eachAxis;
    const zoom = zoomMap?.get(axis.id);
    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
    const range = (0, _getAxisScale.getRange)(drawingArea, 'x', axis);
    const scale = normalizedScales[axis.id].copy();
    const zoomedRange = (0, _zoom.zoomScaleRange)(range, zoomRange);
    scale.range(zoomedRange);
    scales[axis.id] = scale;
  });
  return scales;
});
const selectorChartYScales = exports.selectorChartYScales = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, selectorChartNormalizedYScales, _useChartDimensions.selectorChartDrawingArea, selectorChartZoomMap], function selectorChartYScales(axes, normalizedScales, drawingArea, zoomMap) {
  const scales = {};
  axes?.forEach(eachAxis => {
    const axis = eachAxis;
    const zoom = zoomMap?.get(axis.id);
    const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
    const range = (0, _getAxisScale.getRange)(drawingArea, 'y', axis);
    const scale = normalizedScales[axis.id].copy();
    const scaleRange = (0, _scaleGuards.isOrdinalScale)(scale) ? range.reverse() : range;
    const zoomedRange = (0, _zoom.zoomScaleRange)(scaleRange, zoomRange);
    scale.range(zoomedRange);
    scales[axis.id] = scale;
  });
  return scales;
});

/**
 * The only interesting selectors that merge axis data and zoom if provided.
 */

const selectorChartXAxis = exports.selectorChartXAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartDimensions.selectorChartDrawingArea, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartXDomains, selectorChartXScales], (axis, drawingArea, formattedSeries, seriesConfig, zoomMap, domains, scales) => (0, _computeAxisValue.computeAxisValue)({
  scales,
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig,
  axisDirection: 'x',
  zoomMap,
  domains
}));
const selectorChartYAxis = exports.selectorChartYAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis, _useChartDimensions.selectorChartDrawingArea, _useChartSeries.selectorChartSeriesProcessed, _useChartSeries.selectorChartSeriesConfig, selectorChartZoomMap, selectorChartYDomains, selectorChartYScales], (axis, drawingArea, formattedSeries, seriesConfig, zoomMap, domains, scales) => (0, _computeAxisValue.computeAxisValue)({
  scales,
  drawingArea,
  formattedSeries,
  axis,
  seriesConfig,
  axisDirection: 'y',
  zoomMap,
  domains
}));
const selectorChartAxis = exports.selectorChartAxis = (0, _selectors.createSelector)([selectorChartXAxis, selectorChartYAxis, (_, axisId) => axisId], (xAxes, yAxes, axisId) => xAxes?.axis[axisId] ?? yAxes?.axis[axisId]);
const selectorChartRawAxis = exports.selectorChartRawAxis = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis, _useChartCartesianAxisLayout.selectorChartRawYAxis, (state, axisId) => axisId], (xAxes, yAxes, axisId) => {
  const axis = xAxes?.find(a => a.id === axisId) ?? yAxes?.find(a => a.id === axisId) ?? null;
  if (!axis) {
    return undefined;
  }
  return axis;
});
const selectorChartDefaultXAxisId = exports.selectorChartDefaultXAxisId = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawXAxis], xAxes => xAxes[0].id);
const selectorChartDefaultYAxisId = exports.selectorChartDefaultYAxisId = (0, _selectors.createSelector)([_useChartCartesianAxisLayout.selectorChartRawYAxis], yAxes => yAxes[0].id);
const EMPTY_MAP = new Map();
const selectorChartSeriesEmptyFlatbushMap = () => EMPTY_MAP;
exports.selectorChartSeriesEmptyFlatbushMap = selectorChartSeriesEmptyFlatbushMap;
const selectorChartSeriesFlatbushMap = exports.selectorChartSeriesFlatbushMap = (0, _selectors.createSelector)([_useChartSeries.selectorChartSeriesProcessed, selectorChartNormalizedXScales, selectorChartNormalizedYScales, selectorChartDefaultXAxisId, selectorChartDefaultYAxisId], function selectChartSeriesFlatbushMap(allSeries, xAxesScaleMap, yAxesScaleMap, defaultXAxisId, defaultYAxisId) {
  // FIXME: Do we want to support non-scatter series here?
  const validSeries = allSeries.scatter;
  const flatbushMap = new Map();
  if (!validSeries) {
    return flatbushMap;
  }
  validSeries.seriesOrder.forEach(seriesId => {
    const {
      data,
      xAxisId = defaultXAxisId,
      yAxisId = defaultYAxisId
    } = validSeries.series[seriesId];
    const flatbush = new _Flatbush.Flatbush(data.length);
    const originalXScale = xAxesScaleMap[xAxisId];
    const originalYScale = yAxesScaleMap[yAxisId];
    for (const datum of data) {
      // Add the points using a [0, 1] range so that we don't need to recreate the Flatbush structure when zooming.
      // This doesn't happen in practice, though, because currently the scales depend on the drawing area.
      flatbush.add(originalXScale(datum.x), originalYScale(datum.y));
    }
    flatbush.finish();
    flatbushMap.set(seriesId, flatbush);
  });
  return flatbushMap;
});