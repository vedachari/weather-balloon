{"ast":null,"code":"import { ActiveGesturesRegistry } from \"./ActiveGesturesRegistry.js\";\nimport { KeyboardManager } from \"./KeyboardManager.js\";\nimport { PointerManager } from \"./PointerManager.js\";\n\n/**\n * Configuration options for initializing the GestureManager\n */\n\n/**\n * The primary class responsible for setting up and managing gestures across multiple elements.\n *\n * GestureManager maintains a collection of gesture templates that can be instantiated for\n * specific DOM elements. It handles lifecycle management, event dispatching, and cleanup.\n *\n * @example\n * ```typescript\n * // Basic setup with default gestures\n * const manager = new GestureManager({\n *   root: document.body,\n *   touchAction: 'none',\n *   gestures: [\n *     new PanGesture({ name: 'pan' }),\n *   ],\n * });\n *\n * // Register pan gestures on an element\n * const element = manager.registerElement('pan', document.querySelector('.draggable'));\n *\n * // Add event listeners with proper typing\n * element.addEventListener('panStart', (event) => {\n *   console.log('Pan started');\n * });\n *\n * element.addEventListener('pan', (event) => {\n *   console.log(`Pan delta: ${event.deltaX}, ${event.deltaY}`);\n * });\n *\n * // Custom gesture types\n * interface MyGestureEvents {\n *   custom: { x: number, y: number }\n * }\n * const customManager = new GestureManager<MyGestureEvents>({\n *   root: document.body\n *   gestures: [\n *     new CustomGesture({ name: 'custom' }),\n *   ],\n * });\n * ```\n */\nexport class GestureManager {\n  /** Repository of gesture templates that can be cloned for specific elements */\n  gestureTemplates = (() => new Map())();\n\n  /** Maps DOM elements to their active gesture instances */\n  elementGestureMap = (() => new Map())();\n  activeGesturesRegistry = (() => new ActiveGesturesRegistry())();\n  keyboardManager = (() => new KeyboardManager())();\n\n  /**\n   * Create a new GestureManager instance to coordinate gesture recognition\n   *\n   * @param options - Configuration options for the gesture manager\n   */\n  constructor(options) {\n    // Initialize the PointerManager\n    this.pointerManager = new PointerManager({\n      root: options.root,\n      touchAction: options.touchAction,\n      passive: options.passive\n    });\n\n    // Add initial gestures as templates if provided\n    if (options.gestures && options.gestures.length > 0) {\n      options.gestures.forEach(gesture => {\n        this.addGestureTemplate(gesture);\n      });\n    }\n  }\n\n  /**\n   * Add a gesture template to the manager's template registry.\n   * Templates serve as prototypes that can be cloned for individual elements.\n   *\n   * @param gesture - The gesture instance to use as a template\n   */\n  addGestureTemplate(gesture) {\n    if (this.gestureTemplates.has(gesture.name)) {\n      console.warn(`Gesture template with name \"${gesture.name}\" already exists. It will be overwritten.`);\n    }\n    this.gestureTemplates.set(gesture.name, gesture);\n  }\n\n  /**\n   * Updates the options for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose options should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param options - New options to apply to the gesture\n   * @returns True if the options were successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update pan gesture sensitivity on the fly\n   * manager.setGestureOptions('pan', element, { threshold: 5 });\n   * ```\n   */\n  setGestureOptions(gestureName, element, options) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeOptions`, {\n      detail: options,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Updates the state for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose state should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param state - New state to apply to the gesture\n   * @returns True if the state was successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update total delta for a turnWheel gesture\n   * manager.setGestureState('turnWheel', element, { totalDeltaX: 10 });\n   * ```\n   */\n  setGestureState(gestureName, element, state) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeState`, {\n      detail: state,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Register an element to recognize one or more gestures.\n   *\n   * This method clones the specified gesture template(s) and creates\n   * gesture recognizer instance(s) specifically for the provided element.\n   * The element is returned with enhanced TypeScript typing for gesture events.\n   *\n   * @param gestureNames - Name(s) of the gesture(s) to register (must match template names)\n   * @param element - The DOM element to attach the gesture(s) to\n   * @param options - Optional map of gesture-specific options to override when registering\n   * @returns The same element with properly typed event listeners\n   *\n   * @example\n   * ```typescript\n   * // Register multiple gestures\n   * const element = manager.registerElement(['pan', 'pinch'], myDiv);\n   *\n   * // Register a single gesture\n   * const draggable = manager.registerElement('pan', dragHandle);\n   *\n   * // Register with customized options for each gesture\n   * const customElement = manager.registerElement(\n   *   ['pan', 'pinch', 'rotate'],\n   *   myElement,\n   *   {\n   *     pan: { threshold: 20, direction: ['left', 'right'] },\n   *     pinch: { threshold: 0.1 }\n   *   }\n   * );\n   * ```\n   */\n  registerElement(gestureNames, element, options) {\n    // Handle array of gesture names\n    if (!Array.isArray(gestureNames)) {\n      gestureNames = [gestureNames];\n    }\n    gestureNames.forEach(name => {\n      const gestureOptions = options?.[name];\n      this.registerSingleGesture(name, element, gestureOptions);\n    });\n    return element;\n  }\n\n  /**\n   * Internal method to register a single gesture on an element.\n   *\n   * @param gestureName - Name of the gesture to register\n   * @param element - DOM element to attach the gesture to\n   * @param options - Optional options to override the gesture template configuration\n   * @returns True if the registration was successful, false otherwise\n   */\n  registerSingleGesture(gestureName, element, options) {\n    // Find the gesture template\n    const gestureTemplate = this.gestureTemplates.get(gestureName);\n    if (!gestureTemplate) {\n      console.error(`Gesture template \"${gestureName}\" not found.`);\n      return false;\n    }\n\n    // Create element's gesture map if it doesn't exist\n    if (!this.elementGestureMap.has(element)) {\n      this.elementGestureMap.set(element, new Map());\n    }\n\n    // Check if this element already has this gesture registered\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures.has(gestureName)) {\n      console.warn(`Element already has gesture \"${gestureName}\" registered. It will be replaced.`);\n      // Unregister the existing gesture first\n      this.unregisterElement(gestureName, element);\n    }\n\n    // Clone the gesture template and create a new instance with optional overrides\n    // This allows each element to have its own state, event listeners, and configuration\n    const gestureInstance = gestureTemplate.clone(options);\n    gestureInstance.init(element, this.pointerManager, this.activeGesturesRegistry, this.keyboardManager);\n\n    // Store the gesture in the element's gesture map\n    elementGestures.set(gestureName, gestureInstance);\n    return true;\n  }\n\n  /**\n   * Unregister a specific gesture from an element.\n   * This removes the gesture recognizer and stops event emission for that gesture.\n   *\n   * @param gestureName - Name of the gesture to unregister\n   * @param element - The DOM element to remove the gesture from\n   * @returns True if the gesture was found and removed, false otherwise\n   */\n  unregisterElement(gestureName, element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      return false;\n    }\n\n    // Destroy the gesture instance\n    const gesture = elementGestures.get(gestureName);\n    gesture.destroy();\n\n    // Remove from the map\n    elementGestures.delete(gestureName);\n    this.activeGesturesRegistry.unregisterElement(element);\n\n    // Remove the element from the map if it no longer has any gestures\n    if (elementGestures.size === 0) {\n      this.elementGestureMap.delete(element);\n    }\n    return true;\n  }\n\n  /**\n   * Unregister all gestures from an element.\n   * Completely removes the element from the gesture system.\n   *\n   * @param element - The DOM element to remove all gestures from\n   */\n  unregisterAllGestures(element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures) {\n      // Unregister all gestures for this element\n      for (const [, gesture] of elementGestures) {\n        gesture.destroy();\n        this.activeGesturesRegistry.unregisterElement(element);\n      }\n\n      // Clear the map\n      this.elementGestureMap.delete(element);\n    }\n  }\n\n  /**\n   * Clean up all gestures and event listeners.\n   * Call this method when the GestureManager is no longer needed to prevent memory leaks.\n   */\n  destroy() {\n    // Unregister all element gestures\n    for (const [element] of this.elementGestureMap) {\n      this.unregisterAllGestures(element);\n    }\n\n    // Clear all templates\n    this.gestureTemplates.clear();\n    this.elementGestureMap.clear();\n    this.activeGesturesRegistry.destroy();\n    this.keyboardManager.destroy();\n    this.pointerManager.destroy();\n  }\n}","map":{"version":3,"names":["ActiveGesturesRegistry","KeyboardManager","PointerManager","GestureManager","gestureTemplates","Map","elementGestureMap","activeGesturesRegistry","keyboardManager","constructor","options","pointerManager","root","touchAction","passive","gestures","length","forEach","gesture","addGestureTemplate","has","name","console","warn","set","setGestureOptions","gestureName","element","elementGestures","get","error","event","CustomEvent","detail","bubbles","cancelable","composed","dispatchEvent","setGestureState","state","registerElement","gestureNames","Array","isArray","gestureOptions","registerSingleGesture","gestureTemplate","unregisterElement","gestureInstance","clone","init","destroy","delete","size","unregisterAllGestures","clear"],"sources":["/Users/vedachari/projects/weather-balloon/node_modules/@mui/x-internal-gestures/esm/core/GestureManager.js"],"sourcesContent":["import { ActiveGesturesRegistry } from \"./ActiveGesturesRegistry.js\";\nimport { KeyboardManager } from \"./KeyboardManager.js\";\nimport { PointerManager } from \"./PointerManager.js\";\n\n/**\n * Configuration options for initializing the GestureManager\n */\n\n/**\n * The primary class responsible for setting up and managing gestures across multiple elements.\n *\n * GestureManager maintains a collection of gesture templates that can be instantiated for\n * specific DOM elements. It handles lifecycle management, event dispatching, and cleanup.\n *\n * @example\n * ```typescript\n * // Basic setup with default gestures\n * const manager = new GestureManager({\n *   root: document.body,\n *   touchAction: 'none',\n *   gestures: [\n *     new PanGesture({ name: 'pan' }),\n *   ],\n * });\n *\n * // Register pan gestures on an element\n * const element = manager.registerElement('pan', document.querySelector('.draggable'));\n *\n * // Add event listeners with proper typing\n * element.addEventListener('panStart', (event) => {\n *   console.log('Pan started');\n * });\n *\n * element.addEventListener('pan', (event) => {\n *   console.log(`Pan delta: ${event.deltaX}, ${event.deltaY}`);\n * });\n *\n * // Custom gesture types\n * interface MyGestureEvents {\n *   custom: { x: number, y: number }\n * }\n * const customManager = new GestureManager<MyGestureEvents>({\n *   root: document.body\n *   gestures: [\n *     new CustomGesture({ name: 'custom' }),\n *   ],\n * });\n * ```\n */\nexport class GestureManager {\n  /** Repository of gesture templates that can be cloned for specific elements */\n  gestureTemplates = (() => new Map())();\n\n  /** Maps DOM elements to their active gesture instances */\n  elementGestureMap = (() => new Map())();\n  activeGesturesRegistry = (() => new ActiveGesturesRegistry())();\n  keyboardManager = (() => new KeyboardManager())();\n\n  /**\n   * Create a new GestureManager instance to coordinate gesture recognition\n   *\n   * @param options - Configuration options for the gesture manager\n   */\n  constructor(options) {\n    // Initialize the PointerManager\n    this.pointerManager = new PointerManager({\n      root: options.root,\n      touchAction: options.touchAction,\n      passive: options.passive\n    });\n\n    // Add initial gestures as templates if provided\n    if (options.gestures && options.gestures.length > 0) {\n      options.gestures.forEach(gesture => {\n        this.addGestureTemplate(gesture);\n      });\n    }\n  }\n\n  /**\n   * Add a gesture template to the manager's template registry.\n   * Templates serve as prototypes that can be cloned for individual elements.\n   *\n   * @param gesture - The gesture instance to use as a template\n   */\n  addGestureTemplate(gesture) {\n    if (this.gestureTemplates.has(gesture.name)) {\n      console.warn(`Gesture template with name \"${gesture.name}\" already exists. It will be overwritten.`);\n    }\n    this.gestureTemplates.set(gesture.name, gesture);\n  }\n\n  /**\n   * Updates the options for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose options should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param options - New options to apply to the gesture\n   * @returns True if the options were successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update pan gesture sensitivity on the fly\n   * manager.setGestureOptions('pan', element, { threshold: 5 });\n   * ```\n   */\n  setGestureOptions(gestureName, element, options) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeOptions`, {\n      detail: options,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Updates the state for a specific gesture on a given element and emits a change event.\n   *\n   * @param gestureName - Name of the gesture whose state should be updated\n   * @param element - The DOM element where the gesture is attached\n   * @param state - New state to apply to the gesture\n   * @returns True if the state was successfully updated, false if the gesture wasn't found\n   *\n   * @example\n   * ```typescript\n   * // Update total delta for a turnWheel gesture\n   * manager.setGestureState('turnWheel', element, { totalDeltaX: 10 });\n   * ```\n   */\n  setGestureState(gestureName, element, state) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      console.error(`Gesture \"${gestureName}\" not found on the provided element.`);\n      return;\n    }\n    const event = new CustomEvent(`${gestureName}ChangeState`, {\n      detail: state,\n      bubbles: false,\n      cancelable: false,\n      composed: false\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Register an element to recognize one or more gestures.\n   *\n   * This method clones the specified gesture template(s) and creates\n   * gesture recognizer instance(s) specifically for the provided element.\n   * The element is returned with enhanced TypeScript typing for gesture events.\n   *\n   * @param gestureNames - Name(s) of the gesture(s) to register (must match template names)\n   * @param element - The DOM element to attach the gesture(s) to\n   * @param options - Optional map of gesture-specific options to override when registering\n   * @returns The same element with properly typed event listeners\n   *\n   * @example\n   * ```typescript\n   * // Register multiple gestures\n   * const element = manager.registerElement(['pan', 'pinch'], myDiv);\n   *\n   * // Register a single gesture\n   * const draggable = manager.registerElement('pan', dragHandle);\n   *\n   * // Register with customized options for each gesture\n   * const customElement = manager.registerElement(\n   *   ['pan', 'pinch', 'rotate'],\n   *   myElement,\n   *   {\n   *     pan: { threshold: 20, direction: ['left', 'right'] },\n   *     pinch: { threshold: 0.1 }\n   *   }\n   * );\n   * ```\n   */\n  registerElement(gestureNames, element, options) {\n    // Handle array of gesture names\n    if (!Array.isArray(gestureNames)) {\n      gestureNames = [gestureNames];\n    }\n    gestureNames.forEach(name => {\n      const gestureOptions = options?.[name];\n      this.registerSingleGesture(name, element, gestureOptions);\n    });\n    return element;\n  }\n\n  /**\n   * Internal method to register a single gesture on an element.\n   *\n   * @param gestureName - Name of the gesture to register\n   * @param element - DOM element to attach the gesture to\n   * @param options - Optional options to override the gesture template configuration\n   * @returns True if the registration was successful, false otherwise\n   */\n  registerSingleGesture(gestureName, element, options) {\n    // Find the gesture template\n    const gestureTemplate = this.gestureTemplates.get(gestureName);\n    if (!gestureTemplate) {\n      console.error(`Gesture template \"${gestureName}\" not found.`);\n      return false;\n    }\n\n    // Create element's gesture map if it doesn't exist\n    if (!this.elementGestureMap.has(element)) {\n      this.elementGestureMap.set(element, new Map());\n    }\n\n    // Check if this element already has this gesture registered\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures.has(gestureName)) {\n      console.warn(`Element already has gesture \"${gestureName}\" registered. It will be replaced.`);\n      // Unregister the existing gesture first\n      this.unregisterElement(gestureName, element);\n    }\n\n    // Clone the gesture template and create a new instance with optional overrides\n    // This allows each element to have its own state, event listeners, and configuration\n    const gestureInstance = gestureTemplate.clone(options);\n    gestureInstance.init(element, this.pointerManager, this.activeGesturesRegistry, this.keyboardManager);\n\n    // Store the gesture in the element's gesture map\n    elementGestures.set(gestureName, gestureInstance);\n    return true;\n  }\n\n  /**\n   * Unregister a specific gesture from an element.\n   * This removes the gesture recognizer and stops event emission for that gesture.\n   *\n   * @param gestureName - Name of the gesture to unregister\n   * @param element - The DOM element to remove the gesture from\n   * @returns True if the gesture was found and removed, false otherwise\n   */\n  unregisterElement(gestureName, element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (!elementGestures || !elementGestures.has(gestureName)) {\n      return false;\n    }\n\n    // Destroy the gesture instance\n    const gesture = elementGestures.get(gestureName);\n    gesture.destroy();\n\n    // Remove from the map\n    elementGestures.delete(gestureName);\n    this.activeGesturesRegistry.unregisterElement(element);\n\n    // Remove the element from the map if it no longer has any gestures\n    if (elementGestures.size === 0) {\n      this.elementGestureMap.delete(element);\n    }\n    return true;\n  }\n\n  /**\n   * Unregister all gestures from an element.\n   * Completely removes the element from the gesture system.\n   *\n   * @param element - The DOM element to remove all gestures from\n   */\n  unregisterAllGestures(element) {\n    const elementGestures = this.elementGestureMap.get(element);\n    if (elementGestures) {\n      // Unregister all gestures for this element\n      for (const [, gesture] of elementGestures) {\n        gesture.destroy();\n        this.activeGesturesRegistry.unregisterElement(element);\n      }\n\n      // Clear the map\n      this.elementGestureMap.delete(element);\n    }\n  }\n\n  /**\n   * Clean up all gestures and event listeners.\n   * Call this method when the GestureManager is no longer needed to prevent memory leaks.\n   */\n  destroy() {\n    // Unregister all element gestures\n    for (const [element] of this.elementGestureMap) {\n      this.unregisterAllGestures(element);\n    }\n\n    // Clear all templates\n    this.gestureTemplates.clear();\n    this.elementGestureMap.clear();\n    this.activeGesturesRegistry.destroy();\n    this.keyboardManager.destroy();\n    this.pointerManager.destroy();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}